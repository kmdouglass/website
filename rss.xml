<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kyle M. Douglass</title><link>https://kylemdouglass.com/</link><description>Optics, programming, and biophysics</description><atom:link href="https://kylemdouglass.com/rss.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2024 &lt;a href="mailto:kyle.m.douglass@gmail.com"&gt;Kyle M. Douglass&lt;/a&gt; 
&lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"&gt;
&lt;img alt="Creative Commons License BY-NC-SA"
style="border-width:0; margin-bottom:12px;"
src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"&gt;&lt;/a&gt;</copyright><lastBuildDate>Fri, 22 Nov 2024 10:23:14 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Coordinate Systems for Modeling Microscope Objectives</title><link>https://kylemdouglass.com/posts/coordinate-systems-for-modeling-microscope-objectives/</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;p&gt;A common model for infinity corrected microscope objectives is that of an aplanatic and telecentric optical system. In many developments of this model, emphasis is placed upon the calculation of the electric field near the focus. However, this has the effect that the definition of the coordinate systems and geometry are conflated with the determination of the fields. In addition, making the model amenable to computation often occurs as an afterthought.&lt;/p&gt;
&lt;p&gt;In this post I will explore the geometry of an aplanatic system for modeling high NA objectives with an emphasis on computational implementations. My approach follows Novotny and Hecht&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="https://kylemdouglass.com/posts/coordinate-systems-for-modeling-microscope-objectives/#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt; and Herrera and Quinto-Su&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="https://kylemdouglass.com/posts/coordinate-systems-for-modeling-microscope-objectives/#fn:2"&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;h2&gt;The Model Components&lt;/h2&gt;
&lt;p&gt;The model system is illustrated below:&lt;/p&gt;
&lt;figure&gt;
  &lt;img src="https://kylemdouglass.com/images/aplanatic-telecentric-system.png"&gt;
  &lt;figcaption&gt;A high NA, infinity corrected microscope objective as an aplanatic and telecentric optical system.
&lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;In this model, we abstract over the details of the objective by representing it as four surfaces:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A back focal plane containing an aperture stop&lt;/li&gt;
&lt;li&gt;A back principal plane, \( P \)&lt;/li&gt;
&lt;li&gt;A front principal surface, \( P' \)&lt;/li&gt;
&lt;li&gt;A front focal plane&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The space to the left of the back principal plane is called the infinity space. The space to the right of the front principal surface is called the sample space.&lt;/p&gt;
&lt;p&gt;We let the infinity space refractive index \( n_1 = 1 \) because it is in air. The refractive index \( n_2 \) is the refractive index of the immersion medium.&lt;/p&gt;
&lt;p&gt;The unit vectors \( \mathbf{n} \) are not used in this discussion; they are relevant for computing the fields.&lt;/p&gt;
&lt;h3&gt;Assumptions&lt;/h3&gt;
&lt;p&gt;We make one assumption: the system obeys the sine condition. The meaning of this will be explained later.&lt;/p&gt;
&lt;p&gt;An aplanatic system is one that obeys the sine condition.&lt;/p&gt;
&lt;p&gt;We will not assume the intensity law to conserve energy because it is only necessary when computing the electric field near the focus.&lt;/p&gt;
&lt;h3&gt;The Aperture Stop and Back Focal Plane&lt;/h3&gt;
&lt;p&gt;The aperture stop (AS) of an optical system is the element that limits the angle of the marginal ray.&lt;/p&gt;
&lt;p&gt;The system is telecentric because the aperture stop is located in the back focal plane (BFP). We can shape the focal field by spatially modulating any of the amplitude, phase, or polarization of the incident light in a plane conjugate to the BFP.&lt;/p&gt;
&lt;h3&gt;The Back Principal Plane&lt;/h3&gt;
&lt;p&gt;This is the plane in infinity space at which rays appear to refract. It is a plane because rays coming from a point in the front focal plane all emerge into the infinity space in the same direction.&lt;/p&gt;
&lt;p&gt;Strictly speaking, focus field calculations require us to propagate the field from the AS to the back principal plane before computing the Debye diffraction integral, but this step is often omitted&lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="https://kylemdouglass.com/posts/coordinate-systems-for-modeling-microscope-objectives/#fn:3"&gt;3&lt;/a&gt;&lt;/sup&gt;. The assumptions of paraxial optics should hold here.&lt;/p&gt;
&lt;h3&gt;The Front Principal Surface&lt;/h3&gt;
&lt;p&gt;The front principal surface is the surface at which rays appear to refract in the sample space. It is a surface because&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;this is a non-paraxial system, and&lt;/li&gt;
&lt;li&gt;we assumed the sine condition.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The sine condition states that refraction of a ray coming from an on-axis point in the front focal plane occurs on a spherical cap centered upon the focal point. The distance from the optical axis of the point of intersection of the ray with the surface is proportional to the sine of the angle that the ray makes with the axis.&lt;/p&gt;
&lt;p&gt;The principal surface is in the far field of the electric field coming from the focal region. For this reason, we can represent a point on this surface as representing a single ray or a plane wave&lt;sup id="fnref2:1"&gt;&lt;a class="footnote-ref" href="https://kylemdouglass.com/posts/coordinate-systems-for-modeling-microscope-objectives/#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;h3&gt;The Front Focal Plane&lt;/h3&gt;
&lt;p&gt;This plane is located a distance \( n_2 f \) from the principal surface&lt;sup id="fnref:4"&gt;&lt;a class="footnote-ref" href="https://kylemdouglass.com/posts/coordinate-systems-for-modeling-microscope-objectives/#fn:4"&gt;4&lt;/a&gt;&lt;/sup&gt;. It is not at a distance \( f \) from this surface. This is a result of imaging in an immersion medium.&lt;/p&gt;
&lt;h2&gt;Geometry and Coordinate Systems&lt;/h2&gt;
&lt;h3&gt;The Aperture Stop Radius&lt;/h3&gt;
&lt;p&gt;The aperture stop radius \( R \) corresponds to the distance from the axis to the point where the marginal ray intersects the front prinicpal surface. In the sample space, the marginal ray travels at an angle \( \theta_{max} \) with respect to the axis.&lt;/p&gt;
&lt;p&gt;Under the sine condition, this height is&lt;/p&gt;
&lt;p&gt;$$ R = n_2 f \sin{ \theta_{max} } = f \, \text{NA} $$&lt;/p&gt;
&lt;p&gt;The right-most expression uses the definition of the numerical aperture \( \text{NA} \equiv n \sin{ \theta_{max} } \).&lt;/p&gt;
&lt;p&gt;Compare this result to the oft-cited expression for the entrance pupil diameter of an objective lens: \( D = 2 f \, \text{NA} \). They are the same. This makes sense because an entrance pupil is either&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;an image of an aperture stop, or&lt;/li&gt;
&lt;li&gt;a physical stop.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;The Back Principal Plane&lt;/h3&gt;
&lt;p&gt;There are two independent coordinate systems in the back principal plane:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;the spatial coordinate system defining the far field positions \( \left( x_{\infty} , y_{\infty} \right) \), and&lt;/li&gt;
&lt;li&gt;the coordinate system of the angular spectrum of plane waves \( \left( k_x, k_y \right) \).&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;The Far Field Coordinate System&lt;/h4&gt;
&lt;p&gt;The far field coordinate system may be written in Cartesian form as \( \left( x_{\infty} , y_{\infty} \right) \). It also has a cylindrical representation as&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
\rho &amp;amp;=&amp;amp; \sqrt{x_{\infty}^2 + y_{\infty}^2} \\
\phi &amp;amp;=&amp;amp; \arctan \left( \frac{y_{\infty}}{x_{\infty}} \right)
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;The cylindrical representation appears to be preferred in textbook developments of the model. The Cartesian representation is likely preferred for computational models because it works naturally with two-dimensional arrays of numbers, and because beam shaping elements such as spatial light modulators are rectangular arrays of pixels&lt;sup id="fnref2:2"&gt;&lt;a class="footnote-ref" href="https://kylemdouglass.com/posts/coordinate-systems-for-modeling-microscope-objectives/#fn:2"&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;h4&gt;The Angular Spectrum Coordinate System&lt;/h4&gt;
&lt;p&gt;Each point in the angular spectrum coordinate system represents a plane wave in the sample space that is traveling at an angle \( \theta \) to the axis according to:&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
k_x &amp;amp;=&amp;amp; k \sin \theta \cos \phi \\
k_y &amp;amp;=&amp;amp; k \sin \theta \sin \phi \\
k_z &amp;amp;=&amp;amp; k \cos \theta
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;where \( k = 2 \pi n_2 / \lambda = n_2 k_0 \).&lt;/p&gt;
&lt;p&gt;Along the y-axis ( \( x_{\infty} = 0 \) ), the maximum value of \( k_y \) is \(n_2 k_0 \sin \theta_{max} = k_0 \, \text{NA} \).&lt;/p&gt;
&lt;p&gt;Substitute in the expression \( \text{NA} = R / f \) and we get \(k_{y, max} = k_0 R / f\). But \( R = y_{\infty, max} \). This (and similar reasoning for the x-axis) implies that:&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
k_x &amp;amp;=&amp;amp; k_0 x_{\infty} / f \\
k_y &amp;amp;=&amp;amp; k_0 y_{\infty} / f
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;The above equations link the angular spectrum coordinate system to the far field coordinate system. They are no longer independent once \( f \) and \( \lambda \) are specified.&lt;/p&gt;
&lt;h2&gt;Numerical Meshes&lt;/h2&gt;
&lt;p&gt;There are four free parameters for defining the coordinate systems of the numerical meshes:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The numerical aperture, \( \text{NA} \)&lt;/li&gt;
&lt;li&gt;The wavelength, \( \lambda \)&lt;/li&gt;
&lt;li&gt;The focal length, \( f \)&lt;/li&gt;
&lt;li&gt;The linear mesh size, \( L \)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Below is a figure that illustrates the construction of the meshes. Both the far field and angular spectrum coordinate systems are represented by a \( L \times L \) array. \( L = 16 \) in the figure below. In general the value of \( L \) should be a power of 2 to help ensure the efficiency of the Fast Fourier Transform (FFT). By considering only powers of 2, we need only consider arrays of even size as well.&lt;/p&gt;
&lt;figure&gt;
  &lt;img src="https://kylemdouglass.com/images/pupil-function-simulation-mesh.png"&gt;
  &lt;figcaption&gt;A numeric mesh representing the far field and angular spectrum coordinate systems of a microscope objective. Fields are sampled at the center of each mesh pixel.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;The fields are defined on a region of circular support that is centered on this array. The radius of the domain of the far field coordinate system is \( f \text{NA} \); the radius of the domain of the angular spectrum coordinate system is \( k_0 \text{NA} \).&lt;/p&gt;
&lt;p&gt;The boxes that are bound by the gray lines indicate the location of each field sample. The \( \left( x_{\infty} , y_{\infty} \right) \) and the \( \left( k_x, k_y \right) \) coordinate systems are sampled at the center of each gray box. The origin is therefore not sampled, which will help avoid division by zero errors when the fields are eventually computed.&lt;/p&gt;
&lt;p&gt;The figure suggests that we could create only one mesh and scale it by either \( f \text{NA} \) or \( k_0 \text{NA} \) depending on which coordinate system we are working with. The normalized coordinates become \( \left( x_{\infty} / \left( f \text{NA} \right), y_{\infty} / \left( f \text{NA} \right) \right) \) and \( \left( \left( k_x / \left( k_0 \text{NA} \right), k_y \right) / \left( k_0 \text{NA} \right) \right) \).&lt;/p&gt;
&lt;h3&gt;1D Mesh Example&lt;/h3&gt;
&lt;p&gt;As an example, let \( L = 16 \). To four decimal places, the normalized coordinates are \( -1.0000, -0.8667, \ldots, -0.0667, 0.0667, \ldots, 0.8667, 1.0000 \).&lt;/p&gt;
&lt;p&gt;The spacing between array elements is \( 2 / \left( L - 1 \right) = 0.1333 \). Note that 0 is not included in the 1D mesh as it goes from -0.0667 to 0.0667.&lt;/p&gt;
&lt;p&gt;A 2D mesh is easily constructed from the 1D mesh using tools such as NumPy's &lt;a href="https://numpy.org/doc/stable/reference/generated/numpy.meshgrid.html"&gt;meshgrid&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Back Principal Plane Mesh Spacings&lt;/h3&gt;
&lt;p&gt;In the x-direction, the mesh spacing of the far field coordinate system is&lt;/p&gt;
&lt;p&gt;$$ \Delta x_{\infty} = 2 R / \left( L - 1 \right) = 2 f \text{NA} / \left( L - 1 \right) $$&lt;/p&gt;
&lt;p&gt;In the \( k_x \)-direction, the mesh spacing of the angular spectrum coordinate system is&lt;/p&gt;
&lt;p&gt;$$ \Delta k_x = 2 k_{max} / \left( L - 1 \right) = 2 k_0 \text{NA} / \left( L - 1 \right) $$&lt;/p&gt;
&lt;p&gt;Note the symmetry between these two expressions. One scales with \( f \text{NA} \) and the other \( k_0 \text{NA} \). Recall that these are free parameters of the model.&lt;/p&gt;
&lt;h3&gt;Sample Space Mesh Spacing&lt;/h3&gt;
&lt;p&gt;It is interesting to compute the spacing between mesh elements \( \Delta x \) in the sample space when the fields are eventually computed.&lt;/p&gt;
&lt;p&gt;The sampling angular frequency in the sample space is \( k_S = 2 \pi / \Delta x \).&lt;/p&gt;
&lt;p&gt;The Nyquist-Shannon sampling theory states that the maximum informative angular frequency is \( k_{max} = k_S / 2 \).&lt;/p&gt;
&lt;p&gt;From the previous section, we know that \( k_{max} = \left(L - 1 \right) \Delta k_x / 2 \), and that \( \Delta k_x = 2 k_0 \text{NA} / \left( L - 1 \right) \).&lt;/p&gt;
&lt;p&gt;Combining all the previous expressions and simplifying, we get:&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
k_S &amp;amp;=&amp;amp; 2 k_{max} \\
2 \pi / \Delta x &amp;amp;=&amp;amp; \left(L - 1 \right) \Delta k_x \\
2 \pi / \Delta x &amp;amp;=&amp;amp; \left(L - 1 \right) \left[ 2 k_0 \text{NA} / \left( L - 1 \right) \right] \\
2 \pi / \Delta x &amp;amp;=&amp;amp; \left(L - 1 \right) \left[ 2 \left(2 \pi / \lambda \right) \text{NA} / \left( L - 1 \right) \right]
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;Solving the above expression for \( \Delta x \), we arrive at&lt;/p&gt;
&lt;p&gt;$$ \Delta x = \frac{\lambda}{2 \text{NA}} $$&lt;/p&gt;
&lt;p&gt;which is of course the Abbe diffraction limit.&lt;/p&gt;
&lt;h3&gt;Effect of not Sampling the Origin&lt;/h3&gt;
&lt;p&gt;Herrera and Quinto-Su&lt;sup id="fnref3:2"&gt;&lt;a class="footnote-ref" href="https://kylemdouglass.com/posts/coordinate-systems-for-modeling-microscope-objectives/#fn:2"&gt;2&lt;/a&gt;&lt;/sup&gt; point out that an error will be introduced if we naively apply the FFT to compute the field components in the \( \left( k_x, k_y \right) \) coordinate system because the origin is not sampled, whereas the FFT assumes that we sample the zero frequency component. The effect is that the result of the FFT has a constant phase error that accounts for a half-pixel shift in each direction of the mesh.&lt;/p&gt;
&lt;p&gt;Consider again the 1D mesh example with \(L = 16 \): \( -1.0000, -0.8667, \ldots, -0.0667, 0.0667, \ldots, 0.8667, 1.0000 \)&lt;/p&gt;
&lt;p&gt;In Python and other languages that index arrays starting at 0, the origin is located at \(L / 2 - 0.5 \), i.e. halfway between the samples at index 7 and 8. A lateral shift in Fourier space is equivalent to a phase shift in real space:&lt;/p&gt;
&lt;p&gt;$$ \phi_{shift} \left(X, Y \right) =  -j 2 \pi \frac{0.5}{L} X - j 2 \pi \frac{0.5}{L} Y $$&lt;/p&gt;
&lt;p&gt;where \( X \) and \( Y \) are normalized coordinates.&lt;/p&gt;
&lt;p&gt;At this point, I am uncertain whether the phasor with the above argument needs to be multiplied or divided with the result of the FFT because 1. there are a few typos in the signs for the coordinate system bounds in the manuscript of Herrera and Quinto-Su, and 2. the correction was developed for use in MATLAB, which indexes arrays starting at 1. Once the fields are computed, it would be easy to verify the correct sign of the phase terms following the procedure outlined in Figure 3 of Herrera and Quinto-Su's manuscript.&lt;/p&gt;
&lt;h3&gt;Structure of the Algorithm&lt;/h3&gt;
&lt;p&gt;The algorithm to compute the focus fields will proceed as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;(optional) Propgate the inputs fields from the AS to the back principal plane using paraxial wave propagation&lt;/li&gt;
&lt;li&gt;Input the sampled fields in the back principal plane in the \( \left( x_{\infty}, y_{\infty} \right) \) coordinate system&lt;/li&gt;
&lt;li&gt;Transform the fields to the \( \left( k_x, k_y \right) \) coordinate system&lt;/li&gt;
&lt;li&gt;Compute the fields in the \( \left(x, y, z \right) \) coordinate system using the FFT&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Additional Remarks&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Zero padding the mesh will increase the sample space resolution beyond the Abbe limit, but since the fields remain zero outside of the support, no new information is added.&lt;/li&gt;
&lt;li&gt;On the other hand, zero padding might be required when computing fields going from the sample space to the back principal plane to faithfully reproduce any evanescent components.&lt;/li&gt;
&lt;li&gt;Separating the coordinate system and mesh construction from the calculation of the fields reveals that the two assumptions of the model belong separately to each part. The sine condition is used in the construction of the coodrdinate systems, whereas energy conservation is used when computing the fields.&lt;/li&gt;
&lt;li&gt;This post did not explain how to compute the fields.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Lukas Novotny and Bert Hecht, "Principles of Nano-Optics," Cambridge University Press (2006). &lt;a href="https://doi.org/10.1017/CBO9780511813535"&gt;https://doi.org/10.1017/CBO9780511813535&lt;/a&gt; &lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/coordinate-systems-for-modeling-microscope-objectives/#fnref:1" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/coordinate-systems-for-modeling-microscope-objectives/#fnref2:1" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;Isael Herrera and Pedro A. Quinto-Su, "Simple computer program to calculate arbitrary tightly focused (propagating and evanescent) vector light fields," arXiv:2211.06725 (2022). &lt;a href="https://doi.org/10.48550/arXiv.2211.06725"&gt;https://doi.org/10.48550/arXiv.2211.06725&lt;/a&gt; &lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/coordinate-systems-for-modeling-microscope-objectives/#fnref:2" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/coordinate-systems-for-modeling-microscope-objectives/#fnref2:2" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/coordinate-systems-for-modeling-microscope-objectives/#fnref3:2" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;Marcel Leutenegger, Ramachandra Rao, Rainer A. Leitgeb, and Theo Lasser, "Fast focus field calculations," Opt. Express 14, 11277-11291 (2006). &lt;a href="https://doi.org/10.1364/OE.14.011277"&gt;https://doi.org/10.1364/OE.14.011277&lt;/a&gt; &lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/coordinate-systems-for-modeling-microscope-objectives/#fnref:3" title="Jump back to footnote 3 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:4"&gt;
&lt;p&gt;Sun-Uk Hwang and Yong-Gu Lee, "Simulation of an oil immersion objective lens: A simplified ray-optics model considering Abbe’s sine condition," Opt. Express 16, 21170-21183 (2008). &lt;a href="https://doi.org/10.1364/OE.16.021170"&gt;https://doi.org/10.1364/OE.16.021170&lt;/a&gt; &lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/coordinate-systems-for-modeling-microscope-objectives/#fnref:4" title="Jump back to footnote 4 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><guid>https://kylemdouglass.com/posts/coordinate-systems-for-modeling-microscope-objectives/</guid><pubDate>Thu, 21 Nov 2024 09:52:48 GMT</pubDate></item><item><title>GitHub CLI Authorization with a Fine-grained Access Token</title><link>https://kylemdouglass.com/posts/github-cli-authorization-with-a-fine-grained-access-token/</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;p&gt;It is a good idea to use fine-grained access tokens for shared PCs in the lab that require access to private GitHub repos so that you can restrict the scope of their use to specific repositories and not use your own personal SSH keys on the shared machines. I am experimenting with the GitHub command line tool &lt;code&gt;gh&lt;/code&gt; to authenticate with GitHub using fine-grained access tokens and make common remote operations on repos easier.&lt;/p&gt;
&lt;p&gt;Today I encountered a subtle problem in the &lt;code&gt;gh&lt;/code&gt; authentication process. If you set the protocol to &lt;code&gt;ssh&lt;/code&gt; during login, then you will not have access to the repos that you granted permissions to in the fine-grained access token. This can lead to a lot of head scratching because it's not at all clear which permissions map to which git operations. In other words, what you think is a specific permissions error with the token is actually an authentication error.&lt;/p&gt;
&lt;p&gt;To avoid the problem, be sure to specify &lt;code&gt;https&lt;/code&gt; and not &lt;code&gt;ssh&lt;/code&gt; as the protocol during authentication:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="go"&gt; echo "$ACCESS_TOKEN" | gh auth login -p https --with-token&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><category>github</category><guid>https://kylemdouglass.com/posts/github-cli-authorization-with-a-fine-grained-access-token/</guid><pubDate>Fri, 04 Oct 2024 12:18:48 GMT</pubDate></item><item><title>Raspberry Pi I2C Quickstart</title><link>https://kylemdouglass.com/posts/raspberry-pi-i2c-quickstart/</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;p&gt;Below are my notes concerning the control of a &lt;a href="https://www.sparkfun.com/products/12918"&gt;Sparkfun MCP4725 12-bit DAC&lt;/a&gt; over I2C with a Raspberry Pi.&lt;/p&gt;
&lt;h2&gt;Rasbperry Pi Setup&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Enable the I2C interface if isn't already with &lt;code&gt;raspi-config&lt;/code&gt;. Verify that the I2C device file(s) are present in &lt;code&gt;/dev/&lt;/code&gt; with &lt;code&gt;ls /dev | grep i2c&lt;/code&gt;. (I had two files: &lt;code&gt;i2c-1&lt;/code&gt; and &lt;code&gt;i2c-2&lt;/code&gt;.)&lt;/li&gt;
&lt;li&gt;Install the &lt;code&gt;i2c-tools&lt;/code&gt; package for debugging I2C interfaces.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="go"&gt;sudo apt update &amp;amp;&amp;amp; sudo apt install -y i2c-tools&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;i2cdetect&lt;/h3&gt;
&lt;p&gt;Attach the DAC to the Raspberry Pi. The pinout is simple:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Raspberry Pi&lt;/th&gt;
&lt;th&gt;MCP4725&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GND&lt;/td&gt;
&lt;td&gt;GND&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3.3V&lt;/td&gt;
&lt;td&gt;Vcc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SCL&lt;/td&gt;
&lt;td&gt;SCL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SDA&lt;/td&gt;
&lt;td&gt;SDA&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Next, run  the command &lt;code&gt;i2cdetect -y 1&lt;/code&gt;. This will check for a device on bus 1 (&lt;code&gt;/dev/i2c-1&lt;/code&gt;) and automatically accept confirmations:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="gp"&gt;leb@raspberrypi:~/$ &lt;/span&gt;i2cdetect&lt;span class="w"&gt; &lt;/span&gt;-y&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;
&lt;span class="go"&gt;     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f&lt;/span&gt;
&lt;span class="go"&gt;00:                         -- -- -- -- -- -- -- --&lt;/span&gt;
&lt;span class="go"&gt;10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --&lt;/span&gt;
&lt;span class="go"&gt;20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --&lt;/span&gt;
&lt;span class="go"&gt;30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --&lt;/span&gt;
&lt;span class="go"&gt;40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --&lt;/span&gt;
&lt;span class="go"&gt;50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --&lt;/span&gt;
&lt;span class="go"&gt;60: 60 -- -- -- -- -- -- -- -- -- -- -- -- -- -- --&lt;/span&gt;
&lt;span class="go"&gt;70: -- -- -- -- -- -- -- --&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Each I2C device must have a unique 7-bit address, i.e. 0x00 to 0x7f. The ranges [0x00, 0x07] and [0x78, 0x7f] are reserved. The above output indicates the DAC is at address 0x60. (Rows are the value of the first hexadecimal number of the address, columns are the second.)&lt;/p&gt;
&lt;h3&gt;i2cset&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;i2cset&lt;/code&gt; is a command line tool that is part of &lt;code&gt;i2c-tools&lt;/code&gt; and that is used to write data to I2C devices. I can set the voltage output of the DAC to 0 as follows:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="go"&gt;i2cset -y 1 0x60 0x40 0x00 0x00 i&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The arguments mean the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-y&lt;/strong&gt; : Auto-confirm&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;1&lt;/strong&gt; : Use the device on bus 1&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;0x60&lt;/strong&gt; : Use the device at address &lt;strong&gt;0x60&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;0x40&lt;/strong&gt; : This is a command byte&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;0x00 0x00&lt;/strong&gt; : These two data bytes specify the DAC output level&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;i&lt;/strong&gt; : This is the write mode. &lt;code&gt;i&lt;/code&gt; means I2C block write: &lt;a href="https://docs.kernel.org/i2c/smbus-protocol.html#i2c-block-write"&gt;https://docs.kernel.org/i2c/smbus-protocol.html#i2c-block-write&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Command byte&lt;/h4&gt;
&lt;p&gt;The command byte is explained on pages 23 and 25 of the &lt;a href="https://ww1.microchip.com/downloads/en/devicedoc/22039d.pdf"&gt;MCP4725 datasheet&lt;/a&gt;. From most-significant to least-significant bits, the bits mean:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;C2&lt;/strong&gt; : command bit&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C1&lt;/strong&gt; : command bit&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C0&lt;/strong&gt; : command bit &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;X&lt;/strong&gt; : unused&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;X&lt;/strong&gt; : unused&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PD1&lt;/strong&gt; : Power down select&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PD0&lt;/strong&gt; : Power down select&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;X&lt;/strong&gt; : unused&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;According to Table 6-2 and Figure 6-2, &lt;code&gt;C2, C1, C0 = 0, 1, 0&lt;/code&gt; identifies the command to write to the DAC register and NOT also to the EEPROM. In normal operation, the power down bits are 0, 0 (page 28).&lt;/p&gt;
&lt;p&gt;So, to write to the DAC register, we want to send &lt;code&gt;0b01000000&lt;/code&gt; which in hexadecimal is &lt;code&gt;0x40&lt;/code&gt;.&lt;/p&gt;
&lt;h4&gt;Data bytes to voltage&lt;/h4&gt;
&lt;p&gt;The data bytes are explained in Figure 6-2 of the datasheet. The first byte contains bits 11-4, and the second byte bits 3-0 in the most-significant bits:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;D11 D10 D9 D8   D7 D6 D5 D4 | D3 D2 D1 D0  X X X X&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;12-bits are used because this is a 12-bit DAC. The mapping between bytes and voltage is:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Data bytes, hex&lt;/th&gt;
&lt;th&gt;Data bytes, decimal&lt;/th&gt;
&lt;th&gt;Voltage&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0x00 0x00&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0xFF 0xF0&lt;/td&gt;
&lt;td&gt;65520&lt;/td&gt;
&lt;td&gt;V_max&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;where V_max is the voltage supplied to the chip's Vcc pin (3.3V in my case). The output step size is \( \Delta V = V_{max} / 4096 \) or about 0.8 mV.&lt;/p&gt;
&lt;h2&gt;Control via Python&lt;/h2&gt;
&lt;p&gt;This is modified from &lt;a href="https://learn.sparkfun.com/tutorials/raspberry-pi-spi-and-i2c-tutorial/all"&gt;Sparkfun's tutorial&lt;/a&gt; and uses the smbus Python bindings. Be aware that the tutorial example has a bug in how it prepares the list of bytes to send to the DAC.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;smbus&lt;/span&gt;


&lt;span class="n"&gt;OUTPUT_MAX&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4095&lt;/span&gt;
&lt;span class="n"&gt;V_MAX&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;3.3&lt;/span&gt;


&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;channel&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;device_address&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x60&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;command_byte&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x40&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Output voltage must be expressed as fraction of the maximum in the range [0.0, 1.0]"&lt;/span&gt;

    &lt;span class="n"&gt;bus&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;smbus&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SMBus&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;channel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;output_bytes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;OUTPUT_MAX&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xfff&lt;/span&gt;
    &lt;span class="n"&gt;data_byte_0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;output_bytes&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xff0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;  &lt;span class="c1"&gt;# First data byte&lt;/span&gt;
    &lt;span class="n"&gt;data_bytes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;data_byte_0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;output_bytes&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="c1"&gt;# Second data byte&lt;/span&gt;

    &lt;span class="n"&gt;bus&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write_i2c_block_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;device_address&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;command_byte&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data_bytes&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"__main__"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;float&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.42&lt;/span&gt;
    &lt;span class="n"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sa"&gt;f&lt;/span&gt;&lt;span class="s2"&gt;"Estimated output: &lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;V_MAX&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;Misc.&lt;/h2&gt;
&lt;h3&gt;Basic Calculator &lt;code&gt;bc&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;This is a command line calculator and can be used for hexadecimal, binary, and decimal conversions. Install with &lt;code&gt;apt install bc&lt;/code&gt;.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="gp"&gt;# &lt;/span&gt;Convert&lt;span class="w"&gt; &lt;/span&gt;0x40&lt;span class="w"&gt; &lt;/span&gt;to&lt;span class="w"&gt; &lt;/span&gt;binary
&lt;span class="go"&gt;echo "ibase=16; obase=2; 40" | bc&lt;/span&gt;

&lt;span class="gp"&gt;# &lt;/span&gt;Convert&lt;span class="w"&gt; &lt;/span&gt;0x40&lt;span class="w"&gt; &lt;/span&gt;to&lt;span class="w"&gt; &lt;/span&gt;decimal
&lt;span class="go"&gt;echo "ibase=16; 40" | bc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Note that hexadecimal values must be uppercase, e.g. 0xC7, not 0xc7!&lt;/strong&gt;&lt;/p&gt;</description><category>i2c</category><category>raspberry pi</category><guid>https://kylemdouglass.com/posts/raspberry-pi-i2c-quickstart/</guid><pubDate>Tue, 24 Sep 2024 13:01:45 GMT</pubDate></item><item><title>Persist Internet Connection Sharing after Reboot</title><link>https://kylemdouglass.com/posts/persist-internet-connection-sharing-after-reboot/</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;p&gt;&lt;a href="https://kylemdouglass.com/posts/internet-connection-sharing-for-raspberry-pi-setups/"&gt;In my previous post&lt;/a&gt; I wrote about how to use Microsoft's Internet Connection Sharing to share an internet connection on a Windows machine with a Raspberry Pi. Unfortunately, I learned that the ICS service settings do not persist after the Windows machine reboots, and as a result the ICS connection is lost.&lt;/p&gt;
&lt;p&gt;The fix is explained in &lt;a href="https://learn.microsoft.com/en-us/troubleshoot/windows-client/networking/ics-not-work-after-computer-or-service-restart"&gt;this Microsoft Learn page&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To fix the issue, add a key in the Windows registry with the following information:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Path: HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\SharedAccess&lt;/li&gt;
&lt;li&gt;Type: DWORD&lt;/li&gt;
&lt;li&gt;Setting: EnableRebootPersistConnection&lt;/li&gt;
&lt;li&gt;Value: 1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I then had to reset the shared connection by unchecking and rechecking the boxes in the &lt;code&gt;Sharing&lt;/code&gt; tab of the internet connection as explained previously. After a reboot, I confirmed that I could connect to the Pi without manually re-enabling ICS.&lt;/p&gt;</description><category>networking</category><category>raspberry pi</category><guid>https://kylemdouglass.com/posts/persist-internet-connection-sharing-after-reboot/</guid><pubDate>Tue, 17 Sep 2024 07:52:27 GMT</pubDate></item><item><title>Internet Connection Sharing for Raspberry Pi Setups</title><link>https://kylemdouglass.com/posts/internet-connection-sharing-for-raspberry-pi-setups/</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;p&gt;Today I decided to set up an old Raspberry Pi 3B+ for a task in the lab. After burning the latest Raspberry Pi OS Lite image on the SD card, I booted it up and was faced with the unfortunately common problem of network access. It would have taken days to get IT to register the Pi's MAC address on our system, and I did not want to wait that long.&lt;/p&gt;
&lt;p&gt;Luckily, I had a spare network crossover cable and an extra ethernet interface on my Windows work laptop, so I plugged the Pi directly into the laptop and enabled Microsoft Internet Connection Sharing (ICS) between the network connection through which I was connected to the internet and the connection to the Pi. In my specific example:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Press the Windows key and navigate to &lt;code&gt;View network connections&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Right click on my internet connection (&lt;code&gt;Ethernet 2&lt;/code&gt; in my case), select &lt;code&gt;Properties...&lt;/code&gt;, and then the &lt;code&gt;Sharing&lt;/code&gt; tab.&lt;/li&gt;
&lt;li&gt;Check &lt;code&gt;Allow other network users to connect...&lt;/code&gt; and in the &lt;code&gt;Home networking connection:&lt;/code&gt; dropdown, select the connection corresponding to the Pi (&lt;code&gt;Ethernet&lt;/code&gt; in my case).&lt;/li&gt;
&lt;li&gt;Check &lt;code&gt;Allow other network users to control...&lt;/code&gt;. I'm not sure whether this is necessary.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Click OK and restart the Pi if it's already connected. Once it restarts, it should now have internet access through the laptop.&lt;/p&gt;
&lt;p&gt;Next I wanted to connect with SSH to the Pi from my laptop and I needed to know the Pi's IP address. Luckily, ICS uses the &lt;code&gt;mshome.net&lt;/code&gt; domain name for the network, and the Raspberry Pi by default has the hostname &lt;code&gt;raspberrypi&lt;/code&gt;. So getting the IP is as easy running the &lt;code&gt;ping raspberrypi.mshome.net&lt;/code&gt; command in Powershell.&lt;/p&gt;</description><category>networking</category><category>raspberry pi</category><guid>https://kylemdouglass.com/posts/internet-connection-sharing-for-raspberry-pi-setups/</guid><pubDate>Fri, 13 Sep 2024 13:26:11 GMT</pubDate></item><item><title>The Mono16 Format and Flir Cameras</title><link>https://kylemdouglass.com/posts/the-mono16-format-and-flir-cameras/</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;p&gt;For a long time I had found the Mono16 image format of Flir's cameras a bit strange. In the lab I have several Flir cameras with 12-bit ADC's, but the images they output in Mono16 would span a range from 0 to around 65535. How does the camera map a 12-bit number to a 16-bit number?&lt;/p&gt;
&lt;p&gt;If you search for the Mono16 format you will find that it's a padded format. This means that, in the 12-bit ADC example, 4 bits in each pixel are always 0, and the remaining 12 bits represent the pixel's value. But this should mean that we should get pixel values only between 0 and 2^12 - 1, or 4095. So how is it that we can saturate one of these cameras with values near 65535?&lt;/p&gt;
&lt;p&gt;Today it occurred to me that Flir's Mono16 format might not use all the values in the range [0, 65535]. This is indeed the case, as I show below with an image stack that I acquired from one of these cameras:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;sorted_unique_pixels&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unique&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;images&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ravel&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unique&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;diff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sorted_unique_pixels&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="mi"&gt;48&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="mi"&gt;96&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;144&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;dtype&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;uint16&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This prints all the possible, unique differences between the sorted and flattened pixel values in my particular image stack. Notice how they are all multiples of 16?&lt;/p&gt;
&lt;p&gt;Let's look also at the sorted array of unique values itself:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;sorted_unique_pixels&lt;/span&gt;
&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt; &lt;span class="mi"&gt;5808&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="mi"&gt;5824&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="mi"&gt;5856&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;57312&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;57328&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;57472&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;dtype&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;uint16&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;There are more than a million pixels in this array, yet they all take values that are integer multiples of 16.&lt;/p&gt;
&lt;p&gt;It looks like Flir's Mono16 format rescales the camera's output onto the interval [0, 65535] by introducing "gaps" between the numbers equal to 2^16 - 2^N where N is the bit-depth of the camera's ADC.&lt;/p&gt;
&lt;p&gt;But wait just a moment. Above I said that 4 bits in the Mono16 are zero, but I assumed that these were the most significant bits. If the least significant bits are the zero padding, then the allowed pixel values would be, for example, 
&lt;code&gt;0000 0000 = 0&lt;/code&gt;, &lt;code&gt;0001 0000 = 16&lt;/code&gt;, &lt;code&gt;0010 0000 = 32&lt;/code&gt;, &lt;code&gt;0011 0000 = 48&lt;/code&gt;, etc. (Here I ignored the first 8 bits for clarity.)&lt;/p&gt;
&lt;p&gt;So it appears that Flir is indeed padding the 12-bit ADC data with 0's in its Mono16 format. But, somewhat counter-intuitively, &lt;em&gt;it is the four least significant bits that are the zero padding.&lt;/em&gt; I say this is counter-intuitive because I have another camera that pads the most significant bits, so that the maximum pixel value is really 2^N - 1, with N being the ADC's bit-depth.&lt;/p&gt;</description><category>cameras</category><category>computer vision</category><guid>https://kylemdouglass.com/posts/the-mono16-format-and-flir-cameras/</guid><pubDate>Tue, 27 Aug 2024 12:15:36 GMT</pubDate></item><item><title>Literature Review: An Optical Technique for Remote Focusing in Microscopy</title><link>https://kylemdouglass.com/posts/literature-review-an-optical-technique-for-remote-focusing-in-microscopy/</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;h4&gt;Citation&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://doi.org/10.1016/j.optcom.2007.10.007"&gt;E.J. Botcherby, R. Juškaitis, M.J. Booth, T. Wilson, "An optical technique for remote focusing in microscopy," Optics Communications, Volume 281, Issue 4, 2008, Pages 880-887&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;Abstract&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;We describe the theory of a new method of optical refocusing that is particularly relevant for confocal and multiphoton microscopy systems. This method avoids the spherical aberration that is common to other optical refocusing systems. We show that aberration-free refocusing can be achieved over an axial scan range of 70 μm for a 1.4 NA objective lens. As refocusing is implemented remotely from the specimen, this method enables high axial scan speeds without mechanical interference between the objective lens and the specimen.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Reasons for this Review&lt;/h2&gt;
&lt;p&gt;I am interested in this paper for two reasons:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Recent advances in light sheet microscopy have made the theory of remote focusing more relevant than in the past.&lt;/li&gt;
&lt;li&gt;The paper presents a simplified theory of imaging by a high numerical aperture (NA) objective that is useful for understanding image formation in microscopes without resorting to the usual (and more complicated) Richards and Wolf description.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Problem Addressed by the Paper&lt;/h2&gt;
&lt;p&gt;The introduction lays out the reasons for this paper in a straightforward manner:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The primary bottleneck in 3D microscopy is axial scanning of the sample (what the authors call &lt;strong&gt;refocusing&lt;/strong&gt;).&lt;/li&gt;
&lt;li&gt;Due to fundamental optics, refocusing a high resolution microscope involves varying the objective/sample distance, i.e. the image plane must remain fixed.&lt;/li&gt;
&lt;li&gt;It would be desirable to develop a &lt;strong&gt;simple&lt;/strong&gt; mechanism whereby the objective or sample need not move to achieve refocusing in such microscopes without introducing unwanted aberrations.&lt;ul&gt;
&lt;li&gt;This is because samples are becoming more complex (think embryos, organoids, etc.).&lt;/li&gt;
&lt;li&gt;Adaptive optics to fix these aberrations would introduce too much complexity into the setup. (More on this later.)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Theory of 3D Imaging in Microscopes&lt;/h2&gt;
&lt;p&gt;The theory of 3D imaging is introduced by first considering a perfect imaging system with an object space refractive index of \( n_1 \) and an image space refractive index of \( n_2 \). Such a system transforms all the rays emanating from any point in the 3D object space to converge to a single point in the 3D image space. An image formed by such a system is known as a &lt;strong&gt;stigmatic&lt;/strong&gt; image. Unfortunately, Maxwell, followed by Born and Wolf, showed that such a system is only possible if the magnification is the same in all directions and with magnitude&lt;/p&gt;
&lt;p&gt;$$ \left| M \right| = \frac{n_1}{n_2} $$&lt;/p&gt;
&lt;p&gt;This also implies that conjugate rays must have the same angle with respect to the optical axis.&lt;/p&gt;
&lt;p&gt;$$ \gamma_2 = \pm \gamma_1 $$&lt;/p&gt;
&lt;p&gt;Any system that does not meet these criteria is not a perfect imaging system. However, there exist some conditions whereby the system can create a perfect image if their requirements are satisfied. Under these conditions, a perfect image will be created only for objects of limited extent in the object space. The two conditions that are relevant for microscopy are&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;the sine condition, and&lt;/li&gt;
&lt;li&gt;the Herschel condition.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Under the sine condition, points in a plane transverse to the optical axis are imaged perfectly onto the image plane; points that lie at some axial distance from the object plane suffer from spherical aberration and their images are not stigmatic. In some sense, the Herschel condition is the opposite: on-axis points are imaged stigmatically regardless of their axial position, but off-axis points suffer from aberrations.&lt;/p&gt;
&lt;p&gt;The authors note the important fact that most microscope objectives are designed to satisfy the sine condition. As a result, the image plane must remain fixed so that aberration-free refocusing can only be achieved by varying the sample-objective distance. In the authors' words:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;...it is possible to see why commercial microscopes, operating under the sine condition refocus by changing the distance between the specimen and objective, as any attempt to detect images away from the optimal image plane will lead to a degradation by spherical aberration.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Questions&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Does an ideal imaging system need only produce stigmatic images, or must it also accurately reproduce the relative positions between any pair of points in the image space (up to a proportionality factor)? &lt;/li&gt;
&lt;li&gt;What exactly are the defintions of the sine and Herschel conditions? Is it the equations relating the angles of conjugate rays? Is it based on the subset of the object space that is imaged stigmatically? Or, as we'll see in the next section, are they defined by the mapping of ray heights between principal surfaces? The authors present a few attributes of each condition, but I'm not certain which attributes serve as the definitions and which are consequences of their assumptions being true.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;The General Pupil Function&lt;/h2&gt;
&lt;p&gt;I really liked this section. The authors present a model of a high NA microscope objective that is based on its principal surfaces. They then use a mix of scalar wave theory and ray tracing to explain why the sine condition produces stigmatic images for points near the axis in the focal plane of the objective. I think the value in this model is that it is much more approachable than the electromagnetic Richards and Wolf model for aplanatic systems.&lt;/p&gt;
&lt;p&gt;To recall, the principal planes in paraxial optics are used to abstract away the details of a lens system. Refraction effectively occurs at these planes, and the focal length is measured relative to them. In non-paraxial systems, the principal planes actually become curved surfaces. Interestingly, most of the famous optics texts, such as Born and Wolf, are somewhat quiet about this fact, but it can be found in papers such as &lt;a href="https://opg.optica.org/opn/abstract.cfm?uri=opn-9-2-56"&gt;Mansuripur, Optics and Photonics News, 9, 56-60 (1998)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;So a high NA objective is modeled as a pair of principal surfaces:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The first is a sphere centered on the axis with a radius of curvature equal to the focal distance&lt;/li&gt;
&lt;li&gt;The second is a plane perpendicular to the axis, and they refer to it as the pupil plane&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Another important thing to note is that these surfaces &lt;strong&gt;are not&lt;/strong&gt; the usual reference spheres centered about object and image points and located in the entrance/exit pupils. I think the authors are right to use principal surfaces because many modern objectives are object-space telecentric, which places the entrance pupil at infinity. In this case the concept of a reference sphere sitting in the entrance pupil becomes a bit murky and I do not know whether it's applicable.&lt;/p&gt;
&lt;p&gt;In any case, the authors compute the path length differences between points in the object space in this system and use the sine and Herschel conditions to map the rays from the object to the image space principal surfaces. (Each condition results in a different mapping.) Under the approximation that the extent of the object is small, the equations for the path length differences demonstrate what was stated in the previous section: that the sine condition leads to spherical aberration for points that do not lie in the focal plane of the objective. In fact, the phase profile of the wave (the authors weave between ray and wave optics) exiting the second principal plane is expanded as:&lt;/p&gt;
&lt;p&gt;$$ znk \left[ 1 - \frac{\rho^2 \sin^2 \alpha}{2} + \frac{\rho^4 \sin^4 \alpha}{8} + \cdots \right] $$&lt;/p&gt;
&lt;p&gt;For \( z = 0 \), i.e. the object is in the focal plane, all the terms disappear and we get a flat exit wave. When \( z \neq 0 \):&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Focussing the tube lens is accurately described by the quadratic term, as it operates in the paraxial regime. Unfortunately the higher order terms which represent spherical aberrations cannot be focussed by the tube lens and consequently there is a breakdown of stigmatic imaging for these points.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In other words, &lt;strong&gt;under the sine condition, object points that are outside the focal plane produce curved, non-spherical wavefronts that cannot be focussed to a single point by a tube lens.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If, however, another lens in a reversed orientation was placed so that the curved wavefront from the objective was input into it, it would form a stigmatic image in its image space. This suggests a method for remote focussing.&lt;/p&gt;
&lt;h3&gt;Questions&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Is the second principal surface flat because the image is formed at infinity by a high NA, infinity-corrected objective? What would its radius of curvature be in a finite conjugate objective?&lt;/li&gt;
&lt;li&gt;Is the authors' pupil plane coplanar with the objective's exit pupil? Probably not; I think they're referring to the plane in which we find the objective's pupil function, which is somewhat standard (and confusing) nomenclature in microscopy.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;A Technique for Remote Focusing&lt;/h2&gt;
&lt;p&gt;We arrive now at the crux of the paper. The authors suggest a setup for remote focusing that is free (within limits) of the spherical aberration that is introduced by objectives that satisfy the sine condition. Effectively they image the pupil from one objective onto the other with a 4f system. This ensures that the aberrated wavefront from the first objective is "unaberrated" by the second objective. Then, another microscope images the focal region of the second objective. 3D scanning is achieved by moving the objective of the second microscope (often called O3 in light sheet microscopes).&lt;/p&gt;
&lt;p&gt;There are a few important points:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A 4f system needs to be used between the first (O1) and second (O2) objectives to relay the pupil because it faithfully maps the wavefront without adding any additional phase distortion.&lt;/li&gt;
&lt;li&gt;On a related note, you can't use tube lenses in the 4f system that are not afocal with the objective. These so-called widefield tube lenses do not share a focal plane with the objective. The objective's pupil must be in the front focal plane of the 4f system.&lt;/li&gt;
&lt;li&gt;The "perfect" imaging system of O1/4f system/O2 will have an isotropic magnification of \( n1 / n2 \). This satisfies Maxwell's requirement for 3D stigmatic imaging.&lt;/li&gt;
&lt;li&gt;This approach will not work well for objectives that require specific tube lenses for aberration correction. (Sorry Zeiss.)&lt;/li&gt;
&lt;li&gt;You will not lose resolution as long as the second objective has a higher &lt;em&gt;angular aperture&lt;/em&gt; (not numerical aperture). You can, for example, use a NA 1.4 oil objective for O1 and a NA 0.95 dry objective for O2 because the O2 object space is in air, whereas the O1 object space is in oil with \( n \approx 1.5 \). From the definition of numerical aperture, the sine of the limiting angle of O1 must necessarily be smaller than the air objective.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;At this point I found it amusing that the authors cited "complexity" as a reason for why their approach is superior to adaptive optics in the introduction of this paper.&lt;/p&gt;
&lt;h3&gt;Questions&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;The authors suggest a different approach where a mirror is placed after O2 so that it also serves as O3 and use a beam splitter to direct the light leaving O2 onto a camera. Why don't light sheet microscopes use this setup? Is it because of a loss of photons due to the beam splitter?&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Range of Operation&lt;/h2&gt;
&lt;p&gt;The equation for the path length difference between points in object space depends on the assumption of small object distances. This assumption places a limit on the range of validity of this approach. To quantify this limit, the authors computed the Strehl ratio of the phase of the wavefront in the pupil. Honestly, the calculations of this section look tedious. In the end, and after "some routine but rather protracted calculations, a simple result emerges." The simple result looks kind of ugly, depending, among other things on the sine to the eigth power of the aperture angle. It looks like the approach is valid for distances of several tens of microns on both sides of the focal plane of O1, which is in fact quite useful for many biological samples.&lt;/p&gt;
&lt;p&gt;Ironically, the authors decide at this point that adaptive optics, the approach to remote focusing that is too complex, probably isn't that bad after all. It can be used to extend the range of validity of the authors' approach by correcting the higher order terms that are dropped in the binomial expansion for the optical path difference.&lt;/p&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;The authors go on to experimentally verify the approach in a rather unremarkable experiment of taking z-stacks of beads in two different setups. The PSF in their approach is much less aberrated than a normal widefield microscope over an axial range of about \( \pm 40 \mu m \).&lt;/p&gt;
&lt;p&gt;Overall I quite like the paper because of its simplified theoretical model and clear explantion of the sine condition. I would argue, though, that the approach is not necessarily less complex than some of the alternatives that they rule out in the introduction. Admittedly, arguments over complexity are usually subjective and this doesn't necessarily mean the paper is of low quality. Given that many light sheet approaches are now based on this method, the paper serves as a good theoretical grounding into why remote focusing works and, in some cases, may be necessary.&lt;/p&gt;</description><category>microscopy</category><category>optics</category><guid>https://kylemdouglass.com/posts/literature-review-an-optical-technique-for-remote-focusing-in-microscopy/</guid><pubDate>Thu, 30 May 2024 11:43:39 GMT</pubDate></item><item><title>Automated Testing of Simulation Code via Hypothesis Testing</title><link>https://kylemdouglass.com/posts/testing-simulation-code/</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;h2&gt;Missing a Theory of Testing for Scientific Code&lt;/h2&gt;
&lt;p&gt;If you search the Internet for resources on the theory of testing code, you will find information about the different types of tests and how to write them. You will also find that it is generally accepted among programmers that good code is tested and bad code is not. The problem for scientists and engineers, however, is that the theory concerning the testing of computer code was developed primarily by programmers that work on systems that model business processes. There is little theory on how, for example, to test the outcome of physics simulations. To further exacerbate the problem, scientific programmers feel obliged to write tests without the guidance of such a theory because of the imperative to test their code. This leads to convoluted tests that are difficult to understand and maintain.&lt;/p&gt;
&lt;h3&gt;Scientific Code is Different&lt;/h3&gt;
&lt;p&gt;Code that models business processes is based on explicit rules that are developed from a set of requirements. An example of a rule that a business system might follow is "If a customer has ordered an item and has not paid, then send her an invoice."&lt;/p&gt;
&lt;p&gt;To test the above rule, we write out all the possible cases and write a test for each one. For example:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A customer orders an item without paying. Expected result: an invoice is sent.&lt;/li&gt;
&lt;li&gt;A customer orders an item and pays at the time of checkout: Expected result: no invoice is sent.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I have found that a good way to identify test cases in business logic is to look for if/else statements in a rule. Each branch of the statement should be a different test.&lt;/p&gt;
&lt;p&gt;Now let's consider a physics simulation. I am an optical engineer, so I will use an example from optics. One thing I have often done in my work is to simulate the image formation process of a lens system, including the noise imparted by the camera. A simple model of a CMOS camera pixel is one that takes an input signal in photons, adds shot noise, converts it to photoelectrons, adds dark noise, and then converts the electron signal into analog-to-digital units. Schematically:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;photons&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;--&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;electrons&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;--&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ADUs&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;A simplified Python code snippet that models this process, including noise, is below. An instance of the camera class has a method called &lt;code&gt;snap&lt;/code&gt; that takes input array of photons and converts it to ADUs.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;dataclasses&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;dataclass&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;np&lt;/span&gt;


&lt;span class="nd"&gt;@dataclass&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Camera&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;baseline&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;  &lt;span class="c1"&gt;# ADU&lt;/span&gt;
    &lt;span class="n"&gt;bit_depth&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;
    &lt;span class="n"&gt;dark_noise&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;float&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;6.83&lt;/span&gt;  &lt;span class="c1"&gt;# e-&lt;/span&gt;
    &lt;span class="n"&gt;gain&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;float&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.12&lt;/span&gt;  &lt;span class="c1"&gt;# ADU / e-&lt;/span&gt;
    &lt;span class="n"&gt;quantum_efficiency&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;float&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.76&lt;/span&gt;
    &lt;span class="n"&gt;well_capacity&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;32406&lt;/span&gt;  &lt;span class="c1"&gt;# e-&lt;/span&gt;
    &lt;span class="n"&gt;rng&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Generator&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;default_rng&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;snap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="c1"&gt;# Simulate shot noise and convert to electrons&lt;/span&gt;
        &lt;span class="n"&gt;photoelectrons&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rng&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;poisson&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;quantum_efficiency&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="c1"&gt;# Add dark noise&lt;/span&gt;
        &lt;span class="n"&gt;electrons&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rng&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;normal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;scale&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dark_noise&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;photoelectrons&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;photoelectrons&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="c1"&gt;# Clip to the well capacity to model electron saturation&lt;/span&gt;
        &lt;span class="n"&gt;electrons&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;electrons&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;well_capacity&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="c1"&gt;# Convert to ADU&lt;/span&gt;
        &lt;span class="n"&gt;adu&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;electrons&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gain&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;baseline&lt;/span&gt;

        &lt;span class="c1"&gt;# Clip to the bit depth to model ADU saturation&lt;/span&gt;
        &lt;span class="n"&gt;adu&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;adu&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bit_depth&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;adu&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;astype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;uint16&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;How can we test this code? In this case, there are no if/else statements to help us identify test cases. Some possible solutions are:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;An expert can review it. But what if we don't have an expert? Or, if you are an expert, how do we know that we haven't made a mistake? I have worked professionally as both an optical and a software engineer and I can tell you that I make coding mistakes many times a day. And what if the simulation is thousands of lines of code? This solution, though useful, cannot be sufficient for testing.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Compute what the results ought to be for a given set of inputs. Rules like "If the baseline is 100, and the bit depth is 12, etc., then the output is 542 ADU" are not that useful here because the output is random.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Evaluate the code and manually check that it produces the desired results. This is similar to expert review. The problem with this approach is that you would need to recheck the code every time a change is made. One of the advantages of testing business logic is that the tests can be automated. It would be advantageous to preserve automation in testing scientific code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We could always fix the value of the seed for the random number generator to at least make the test deterministic, but then we would not know whether the variation in the simulation output is what we would expect from run-to-run. I'm also unsure whether the same seed produces the same results across different hardware architectures. Since the simulation is non-deterministic at its core, it would be nice to include this attribute within the test case.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Automated Testing of Simulation Results via Hypothesis Testing&lt;/h2&gt;
&lt;p&gt;The solution that I have found to the above-listed problems is derived from ideas that I learned in a class on quality control that I took in college. In short, we run the simulation a number of times and compute one or more statistics from the results. The statistics are compared to their theoretical values in a hypothesis test, and, if the result is outside of a given tolerance, the test fails. If the probability of failure is made small enough, then a failure of the test &lt;strong&gt;practically&lt;/strong&gt; indicates an error in the simulation code rather than a random failure due to the stochastic output.&lt;/p&gt;
&lt;h3&gt;Theoretical Values for Test Statistics&lt;/h3&gt;
&lt;p&gt;In the example of a CMOS camera, both the theoretical mean and the variance of a pixel are known. The &lt;a href="https://www.emva.org/standards-technology/emva-1288/"&gt;EMVA 1288 Linear Model&lt;/a&gt; states that&lt;/p&gt;
&lt;p&gt;$$ \mu_y = K \left( \eta \mu_p + \mu_d \right) + B $$&lt;/p&gt;
&lt;p&gt;where \( \mu_y \) is the mean ADU count, \( K \) is the gain, \( \eta \) is the quantum efficiency, \( \mu_p \) is the mean photon count, \( \mu_d \) is the mean dark noise, and \( B \) is the baseline value, i.e. the average ADU count under no illumination. Likewise, the variance of the pixel describes the noise:&lt;/p&gt;
&lt;p&gt;$$ \sigma_y = \sqrt{K^2 \sigma_d^2 + \sigma_q^2 + K \left( \mu_y - B \right)} $$&lt;/p&gt;
&lt;p&gt;where \( \sigma_y \) is the standard deviation of the ADU counts, \( \sigma_d^2 \) is the dark noise variance, and \( \sigma_q^2 = 1 / 12 \, \text{ADU} \) is the quantization noise, i.e. the noise from converting an analog voltage into discrete ADU values.&lt;/p&gt;
&lt;h3&gt;Hypothesis Testing&lt;/h3&gt;
&lt;p&gt;We can formulate a hypothesis test for each test statistic. The test for each is:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Null hypothesis :&lt;/strong&gt; the simulation statistics and the theoretical values are the same&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Alternative hypothesis :&lt;/strong&gt; the simulation statistics and the theoretical values are different&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Let's first focus on the mean pixel values. To perform this hypothesis test, I ran the simulation code a number of times. For convenience, I chose an input signal of 1000 photons. Here's the resulting histogram:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://kylemdouglass.com/images/camera-mean-adus.png"&gt;&lt;/p&gt;
&lt;p&gt;The mean of this distribution is 190.721 ADU and the standard deviation is 3.437 ADU. The theoretical values are 191.2 ADU and 3.420 ADU, respectively. Importantly, if I re-run the simulation, then I get a different histogram because the simulation's output is random.&lt;/p&gt;
&lt;p&gt;The above histogram is called the &lt;strong&gt;sampling distribution of the mean&lt;/strong&gt;, and its width is proportional to the &lt;strong&gt;standard error of the mean&lt;/strong&gt;. (&lt;em&gt;Edit 2024/05/30&lt;/em&gt; Actually, I think I am wrong here. This is not the sampling distribution of the mean. To get it we would need to repeat the above experiment a number of times and compute the mean each time, much like I do in the following section. The set of all means from doing so would be its sampling distribution. Fortunately, the estimate of the confidence intervals in what follows should still hold because the sampling distribution of the mean tends to a normal distribution for large \(N \), and this allows for the expression in the equation that follows.)&lt;/p&gt;
&lt;h4&gt;Hypothesis Testing of the Mean Pixel Value&lt;/h4&gt;
&lt;p&gt;To perform the hypthosesis test on the mean, I build a confidence interval around the simulated value using the following formula:&lt;/p&gt;
&lt;p&gt;$$ \mu_y \pm X \frac{s}{\sqrt{N}} $$&lt;/p&gt;
&lt;p&gt;Here \( s \) is my estimated standard deviation (3.437 ADU in the example above), and \( N = 10,000 \) is the number of simulated values. Their ratio \( \frac{s}{\sqrt{N}} \) is an estimate of the &lt;strong&gt;standard error of the mean&lt;/strong&gt;. \( X \) is a proportionality factor that is essentially a tolerance on how close the simulated value must be to the theoretical one to be considered "equal". A larger tolerance means that it is less likely that the hypothesis test will fail, but I am less certain that the value of the simulation is exactly equal to the theoretical value.&lt;/p&gt;
&lt;p&gt;If this looks familiar, it should. In introductory statistics classes, this approach is called &lt;a href="https://en.wikipedia.org/wiki/Student%27s_t-test"&gt;Student's one sample t-test&lt;/a&gt;. In the t-test, the value for \( X \) is denoted as \( t \) and depends on the desired confidence level and on the number of data points in the sample. (Strictly speaking, it's the number of data points minus 1.)&lt;/p&gt;
&lt;p&gt;As far as I can tell there's no rule for selecting a value of \( X \); rather, it's a free parameter. I often choose 3. Why? Well, if the sampling distribution is approximately normally distributed, and the number of sample points is large, then the theoretical mean should lie within 3 standard errors of the simulated one approximately 99.7% of the time &lt;strong&gt;if the algorithm is correct.&lt;/strong&gt; Alternatively, this means that a correct simulation will produce a result that is more than three standard errors from the theoretical mean about every 1 out of 370 test runs.&lt;/p&gt;
&lt;h4&gt;Hypothesis Testing of the Noise&lt;/h4&gt;
&lt;p&gt;Recall that standard deviation of pixel values is a measure of the noise. The approach to testing it remains the same as before. We write the confidence interval as&lt;/p&gt;
&lt;p&gt;$$ \sigma_y \pm X \left( s.e. \right) $$&lt;/p&gt;
&lt;p&gt;where we have \( s.e. \) as the standard error of the standard deviation. If the simulated standard deviation is outside this interval, then we reject the null hypothesis and fail the test.&lt;/p&gt;
&lt;p&gt;Now, how do we calculate the standard error of the standard deviation? Unlike with the mean value, we have only one value for the standard deviation of the pixel values. Furthermore, there doesn't seem to be a simple formula for the standard error of the variance or standard error of the standard deviation. (I looked around the Math and Statistics Stack Exchanges, but what I did find produced standard errors that were way too large.)&lt;/p&gt;
&lt;p&gt;Faced with this problem, I have two options:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;run the simulation a number of times to get a distribution of standard deviations&lt;/li&gt;
&lt;li&gt;draw pixel values from the existing simulation data &lt;strong&gt;with replacement&lt;/strong&gt; to estimate the sampling distribution. This approach is known as &lt;a href="https://en.wikipedia.org/wiki/Bootstrapping_(statistics)"&gt;bootstrapping&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In this situation, both are valid approaches because the simulation runs quite quickly. However, if the simulation is slow, bootstrapping might be desirable because resampling the simulated data is relatively fast.&lt;/p&gt;
&lt;p&gt;I provide below a function that makes a bootstrap estimate of the standard error of pixel values to give you an idea of how this works. It draws &lt;code&gt;n&lt;/code&gt; samples from the simulated pixel values with replacement and places the results in the rows of an array. Then, the standard devation of each row is computed. Finally, since the standard error is the standard deviation of the sampling distribution, the standard deviation of resampled standard deviations is computed and returned.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;se_std&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;samples&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;choice&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ravel&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;replace&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;std_sampling_distribution&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;samples&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;axis&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std_sampling_distribution&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Of course, the value of &lt;code&gt;n&lt;/code&gt; in the function above is arbitrary. From what I can tell, setting &lt;code&gt;n&lt;/code&gt; to be the size of the data is somewhat standard practice.&lt;/p&gt;
&lt;h4&gt;Automated Hypothesis Testing&lt;/h4&gt;
&lt;p&gt;At this point, we can calculate the probability that the mean and standard deviation of the simulated pixel values will lie farther than some distance from their theoretical values. This means that we know roughly how often a test will fail due to pure luck.&lt;/p&gt;
&lt;p&gt;To put these into an automated test function, we need only translate the two hypotheses into an assertion. The null hypothesis should correspond to the argument of the assertion being true; the alternative hypothesis corresponds to a false argument.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;TOL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_cmos_camera&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;camera&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;num_pixels&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt;
    &lt;span class="n"&gt;mean_photons&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;
    &lt;span class="n"&gt;photons&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mean_photons&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ones&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_pixels&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;astype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;uint8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;expected_mean&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;191.2&lt;/span&gt;
    &lt;span class="n"&gt;expected_std&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;3.42&lt;/span&gt;

    &lt;span class="n"&gt;img&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;camera&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;snap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;photons&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;tol_mean&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TOL&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sqrt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_pixels&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;num_pixels&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="n"&gt;tol_std&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TOL&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;se_std&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isclose&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mean&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;expected_mean&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;atol&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;tol_mean&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isclose&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;expected_std&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;atol&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;tol_std&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With a &lt;code&gt;TOL&lt;/code&gt; value of 3 and with the sampling distributions being more-or-less normally distributed, each assertion should fail about 1 / 370 times because the area in the tails of the distribution beyond three standard errors is 1 / 370. We can put this test into our test suite and continuous integration (CI) system and run it automatically using whatever tools we wish, e.g. GitHub Actions and pytest.&lt;/p&gt;
&lt;h2&gt;Discussion&lt;/h2&gt;
&lt;h3&gt;Non-deterministic Tests&lt;/h3&gt;
&lt;p&gt;It is an often-stated rule of thumb that automated tests should never fail randomly because it makes failures difficult to diagnose and makes you likely to ignore the tests. Here however it is in the very nature of this test that it will fail randomly from time to time. What are we to do?&lt;/p&gt;
&lt;p&gt;An easy solution would be to isolate these sorts of tests and run them separately from the deterministic ones so that we know exactly where the error occurred. Then, if there is a failure of the non-deterministic tests, the CI could just run them again. If &lt;code&gt;TOL&lt;/code&gt; is set so that a test failure is very rare, then any failure of these tests twice would practically indicate a failure of the algorithm to produce the theoretical results.&lt;/p&gt;
&lt;h3&gt;Testing Absolute Tolerances&lt;/h3&gt;
&lt;p&gt;It could be argued that what I presented here is a lot of work just to make an assertion that a simulation result is close to a known value. In other words, it's just a fancy way to test for absolute tolerances, and possibly is more complex than it needs to be. I can't say that I entirely disagree with this.&lt;/p&gt;
&lt;p&gt;As an alternative, consider the following: if we run the simulation a few times we can get a sense of the variation in its output, and we can use these values to roughly set a tolerance that states by how much the simulated and theoretical results should differ. This is arguably faster than constructing the confidence intervals like we did above.&lt;/p&gt;
&lt;p&gt;The value in the hypothesis testing approach is that you can know the probability of failure to a high degree of accuracy. Whether or not this is important probably depends on what you want to do, but it does provide you with a deeper understanding of the behavior of the simulation that might help debug difficult problems.&lt;/p&gt;
&lt;h3&gt;Testing for Other Types of Errors&lt;/h3&gt;
&lt;p&gt;There are certainly other problems in testing simulation code that are not covered here. The above approach won't tell you directly if you have entered an equation incorrectly. It also requires theoretical values for the summary statistics of the simulation's output. If you have a theory for these already, you might argue that a simulation would be superfluous.&lt;/p&gt;
&lt;p&gt;If it's easy to implement automated tests for your simulation that are based on hypothesis testing, and if you expect the code to change often, then having a few of these sorts of tests will at least provide you a degree of confidence that everything is working as you expect as you make changes. And that is one of the goals of having automated tests: fearless refactoring.&lt;/p&gt;
&lt;h3&gt;Testing the Frequency of Failures&lt;/h3&gt;
&lt;p&gt;I stated often that with hypothesis testing we know how often the code should fail, but we never actually tested that. We could have run the simulation a large number of times and verified that the number of failures was approximately equal to the theoretical number of failures.&lt;/p&gt;
&lt;p&gt;To my mind, it seems that this is just the exact same problem that was addressed above, but instead of testing summary statistics on the output values we test the number of failures. And since the number of failures will vary randomly, we would need a sampling distribution for this. So really this approach requires more CPU clock cycles to do the same thing because we need to run the simulation a large number of times.&lt;/p&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Automated testing of simulation code is different than testing business logic due to its stochastic nature and inability to be reduced to "rules"&lt;/li&gt;
&lt;li&gt;We can formulate hypothesis tests to determine how often the simulation produces values that are farther than a given distance from what theory predicts&lt;/li&gt;
&lt;li&gt;The hypothesis tests can be translated into test cases: accepting the null hypothesis means the test passes, whereas rejecting the null hypothesis means the test fails&lt;/li&gt;
&lt;li&gt;Non-deterministic testing is useful when it is quick to implement and you expect to change the code often&lt;/li&gt;
&lt;/ul&gt;</description><category>cameras</category><category>simulation</category><category>statistics</category><guid>https://kylemdouglass.com/posts/testing-simulation-code/</guid><pubDate>Tue, 21 May 2024 07:54:40 GMT</pubDate></item><item><title>French Vocabulary for Machinists</title><link>https://kylemdouglass.com/posts/french-vocabulary-for-machinists/</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;p&gt;I work in a French-speaking country and frequently need to communicate with our machinists, many of whom do not speak English.&lt;/p&gt;
&lt;p&gt;Here is a list of English-French vocabulary words that I have found useful. I will update it as I learn more words.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Last update: 2024-04-18&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;Materials and processing&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;aluminum&lt;/strong&gt;, &lt;em&gt;n&lt;/em&gt; : aluminium (m)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;anodized&lt;/strong&gt;, &lt;em&gt;adj&lt;/em&gt; : anodisé&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;stainless steel&lt;/strong&gt;, &lt;em&gt;n&lt;/em&gt; : 1. acier inoxydable, 2. inox (the cool way to say it)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Measurements&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;dimensions&lt;/strong&gt;, &lt;em&gt;npl&lt;/em&gt; : les dimensions (fpl) &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Screws, bolts, fasteners, etc.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;latch&lt;/strong&gt;, &lt;em&gt;n&lt;/em&gt; : un loquet (possibly Swiss-French)&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;push latch&lt;/strong&gt;, &lt;em&gt;n&lt;/em&gt; : un loquet poussoir&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;screw&lt;/strong&gt;, &lt;em&gt;n&lt;/em&gt; : une vis&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;cap (or head) screw&lt;/strong&gt;, &lt;em&gt;n&lt;/em&gt; : une vis à tête&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;countersunk cap screw&lt;/strong&gt;, &lt;em&gt;n&lt;/em&gt; : vis à tête fraisée&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;spring&lt;/strong&gt;, &lt;em&gt;n&lt;/em&gt; : un ressort&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;threading&lt;/strong&gt;, &lt;em&gt;n&lt;/em&gt; : un filetage&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;exterior threads&lt;/strong&gt; : 1. filetage extérieur, 2. filetages mâles &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;interior threads&lt;/strong&gt; : 1. filetage intérieur, 2. filetages femelles  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Tools&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;die&lt;/strong&gt;, &lt;em&gt;n&lt;/em&gt; : une filière&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;lathe&lt;/strong&gt;, &lt;em&gt;n&lt;/em&gt; : un tour&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;mill&lt;/strong&gt;, &lt;strong&gt;milling machine&lt;/strong&gt;, &lt;em&gt;n&lt;/em&gt; : une fraiseuse&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tap&lt;/strong&gt;, &lt;em&gt;n&lt;/em&gt; : un taraud&lt;/li&gt;
&lt;/ul&gt;</description><category>french</category><guid>https://kylemdouglass.com/posts/french-vocabulary-for-machinists/</guid><pubDate>Thu, 28 Mar 2024 08:35:27 GMT</pubDate></item><item><title>Engineering Fits</title><link>https://kylemdouglass.com/posts/engineering-fits/</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;p&gt;I have been working on some optomechanical parts that require a hole-and-shaft style mating. During their design, I realized I really didn't have any theoretical background on how big the holes and shafts should be so that they fit together. This lead me to do some basic research into &lt;strong&gt;engineering fits&lt;/strong&gt;.&lt;/p&gt;
&lt;h2&gt;Engineering Fits&lt;/h2&gt;
&lt;p&gt;According to &lt;cite&gt;Building Scientific Apparatus, 4th ed.&lt;a href="https://www.cambridge.org/core/books/building-scientific-apparatus/52BB9BC3EDF3A8F604EF95D83901AA00"&gt;1&lt;/a&gt;&lt;/cite&gt;, fit should be specified when the absolute size of two mating parts is not important, but the clearance between them is critical.&lt;/p&gt;
&lt;p&gt;To understand fits, it helps first to think in terms of active surfaces and tolerances.&lt;/p&gt;
&lt;p&gt;An &lt;strong&gt;active surface&lt;/strong&gt; is a region where two surfaces touch and either move against each other or have a static fit &lt;a href="https://formlabs.com/eu/blog/3D-printing-tolerances-for-engineering-fit/"&gt;2&lt;/a&gt;. (Interestingly, an active surface is really two physical surfaces by this definition.) The tolerances on the size of two mating parts determines the type of fit. An example of the tolerances on a hole-and-shaft assembly is shown below.&lt;/p&gt;
&lt;p&gt;&lt;svg width="150mm" height="100mm" viewbox="0 0 150 100" version="1.1" id="svg5" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"&gt;
  &lt;defs id="defs2"&gt;&lt;/defs&gt;
  &lt;g id="layer1"&gt;
    &lt;g id="g17422" transform="translate(4.3342147,0.28437662)"&gt;
      &lt;g id="g18330" transform="translate(7.3550761,0.97463966)"&gt;
        &lt;rect style="fill:#a8a8a8;fill-opacity:1;stroke:none;stroke-width:0.0499999;stroke-linecap:square;stroke-dasharray:0.0999994, 0.199999;stroke-dashoffset:0;stroke-opacity:1" id="rect8681" width="61.416935" height="6.1849809" x="-1.2360383" y="24.001053" ry="2.3741585e-07"&gt;&lt;/rect&gt;
        &lt;rect style="fill:#a8a8a8;fill-opacity:1;stroke:none;stroke-width:0.0499999;stroke-linecap:square;stroke-dasharray:0.0999994, 0.199999;stroke-dashoffset:0;stroke-opacity:1" id="rect8943" width="61.416935" height="6.1849809" x="-1.2359573" y="67.295868" ry="2.3741585e-07"&gt;&lt;/rect&gt;
        &lt;rect style="fill:none;fill-opacity:1;stroke:#000000;stroke-width:0.199999;stroke-linecap:square;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" id="rect8621" width="61.416935" height="92.190269" x="-1.2359573" y="2.645849" ry="1.7694015e-07"&gt;&lt;/rect&gt;
        &lt;path style="fill:none;fill-opacity:1;stroke:#000000;stroke-width:0.199999;stroke-linecap:square;stroke-dasharray:0.399999, 0.799999;stroke-dashoffset:0;stroke-opacity:1" d="M 60.180883,27.093527 H -1.2360264" id="path8677"&gt;&lt;/path&gt;
        &lt;path style="fill:none;fill-opacity:1;stroke:#000000;stroke-width:0.199999;stroke-linecap:square;stroke-dasharray:0.399999, 0.799999;stroke-dashoffset:0;stroke-opacity:1" d="M 60.18099,70.388445 H -1.2360264" id="path8679"&gt;&lt;/path&gt;
        &lt;rect style="fill:#a8a8a8;fill-opacity:1;stroke:none;stroke-width:0.199999;stroke-linecap:square;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" id="rect9673" width="61.708443" height="6.1849813" x="66.149086" y="62.016087" ry="2.3741585e-07"&gt;&lt;/rect&gt;
        &lt;rect style="fill:#a8a8a8;fill-opacity:1;stroke:none;stroke-width:0.199999;stroke-linecap:square;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" id="rect9677" width="61.708443" height="6.1849813" x="66.149086" y="31.09115" ry="2.3741585e-07"&gt;&lt;/rect&gt;
        &lt;rect style="fill:none;fill-opacity:1;stroke:#000000;stroke-width:0.199999;stroke-linecap:square;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" id="rect9671" width="61.708359" height="30.924906" x="66.149086" y="34.183422" ry="2.3741585e-07"&gt;&lt;/rect&gt;
        &lt;g id="g18315" transform="translate(-24.896546)"&gt;
          &lt;rect style="fill:#a8a8a8;fill-opacity:1;stroke:none;stroke-width:0.2;stroke-linecap:square;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" id="rect16362" width="9.260376" height="3.6321862" x="90.945633" y="88.398582" ry="1.394246e-07"&gt;&lt;/rect&gt;
          &lt;text xml:space="preserve" style="font-size:4.23333px;font-family:Arial;-inkscape-font-specification:'Arial, Normal';text-align:center;text-anchor:middle;fill:#000000;fill-opacity:1;stroke:none;stroke-width:0.0499999;stroke-linecap:square;stroke-linejoin:bevel;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" x="118.46138" y="91.428886" id="text12648"&gt;&lt;tspan id="tspan12646" style="font-size:4.23333px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:0.05" x="118.46138" y="91.428886"&gt;Tolerance Ranges&lt;/tspan&gt;&lt;/text&gt;
        &lt;/g&gt;
        &lt;path style="fill:#000000;fill-opacity:1;stroke:#000000;stroke-width:0.199999;stroke-linecap:butt;stroke-linejoin:round;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" d="M 66.149086,49.64587 H 52.638712 l 0.728979,-0.628177 v 1.351618 L 52.638712,49.64587" id="path16428"&gt;&lt;/path&gt;
      &lt;/g&gt;
    &lt;/g&gt;
  &lt;/g&gt;
&lt;/svg&gt;&lt;/p&gt;
&lt;h3&gt;Fit definitions&lt;/h3&gt;
&lt;p&gt;In this context, we can define three types of fits:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;Clearance fits&lt;/em&gt; : Tolerance zones do not overlap&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Transition fits&lt;/em&gt; : Tolerance zones partially overlap&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Interference fits&lt;/em&gt; : Tolerance zones fully overlap&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;These fits exist on a continuum and are not neatly distinguished in practice. The continuum can be seen by plotting the force required for mating vs. the allowance. The allowance in this context can be defined as follows&lt;a href="https://waykenrm.com/blogs/difference-between-tolerance-and-allowance/"&gt;3&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;\[ \text{allowance} = \text{smallest hole} - \text{largest shaft} \]&lt;/p&gt;
&lt;h4&gt;Clearance fits&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;Sliding fit&lt;/em&gt; : Some lateral play&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Running fit&lt;/em&gt; : More fricition, but more accurate motion&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Transition fits&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;Keyring fit&lt;/em&gt; : Slight force required for mating and easy to remove&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Push fit&lt;/em&gt; : More force required; possible to remove by hand&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Interference fits&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;Force fit&lt;/em&gt; : Hand tools likely required for mating&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Press fit&lt;/em&gt; : Requires more force, likely using a press&lt;/li&gt;
&lt;/ol&gt;</description><category>3d printing</category><category>fits</category><guid>https://kylemdouglass.com/posts/engineering-fits/</guid><pubDate>Tue, 26 Mar 2024 10:48:49 GMT</pubDate></item></channel></rss>