<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kyle M. Douglass</title><link>https://kylemdouglass.com/</link><description>Optics, programming, and biophysics</description><atom:link href="https://kylemdouglass.com/rss.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2025 &lt;a href="mailto:kyle.m.douglass@gmail.com"&gt;Kyle M. Douglass&lt;/a&gt; 
&lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"&gt;
&lt;img alt="Creative Commons License BY-NC-SA"
style="border-width:0; margin-bottom:12px;"
src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"&gt;&lt;/a&gt;</copyright><lastBuildDate>Mon, 23 Jun 2025 06:57:16 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Why is Camera Read Noise Gaussian Distributed?</title><link>https://kylemdouglass.com/posts/why-is-camera-read-noise-gaussian-distributed/</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;p&gt;As a microscopist I work with very weak light signals, often just tens of photons per camera pixel. The images I record are noisy as a result&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="https://kylemdouglass.com/posts/why-is-camera-read-noise-gaussian-distributed/#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;. To a good approximation, the value of a pixel is a sum of two random variables describing two different physical processes:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;photon shot noise, which is described by a Poisson probability mass function, and&lt;/li&gt;
&lt;li&gt;camera read noise, which is described by a Gaussian probability density function.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Read noise has units of electrons, which must be discrete, positive integers. So why is it modeled as a continuous probability density function&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="https://kylemdouglass.com/posts/why-is-camera-read-noise-gaussian-distributed/#fn:2"&gt;2&lt;/a&gt;&lt;/sup&gt;?&lt;/p&gt;
&lt;h2&gt;The Source(s) of Read Noise&lt;/h2&gt;
&lt;p&gt;Janesick&lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="https://kylemdouglass.com/posts/why-is-camera-read-noise-gaussian-distributed/#fn:3"&gt;3&lt;/a&gt;&lt;/sup&gt; defines read noise as "any noise source that is not a function of signal." This means that there is not necessarily one single source of read noise. It is commonly understood that it comes from somewhere in the camera electronics, but "somewhere" need not imply that it is isolated to one location.&lt;/p&gt;
&lt;p&gt;The signal from a camera pixel is the number of photoelectrons that were generated inside the pixel. I imagine readout of this signal as a linear path consisting of many steps. The signal might change form along this path, such as going from number of electrons to a voltage. At each step, there is a small probability that some small error is added to (or maybe also removed from?) the signal. The final result is a value that differs randomly from the original signal.&lt;/p&gt;
&lt;p&gt;Importantly, I do not think that it matters which physical process each step actually represents; rather there just has to be many of them for this abstraction to be valid.&lt;/p&gt;
&lt;p&gt;"But aren't there only a handful of steps?" you might ask. After all, linear models of photon transfer typically consist of a few processes such as detection, amplification, readout, and analog-to-digital conversion. I am not referring to these when I use the term "step." Rather, I am referring to processes that are much more microscopic, such as passage of a signal through a transistor or amplifier chip. At the very least Johnson noise, or random currents induced by thermal motion of the charge carriers, will be present in all of the camera's components.&lt;/p&gt;
&lt;h2&gt;Read Noise is Gaussian because of the Central Limit Theorem&lt;/h2&gt;
&lt;p&gt;The reason for my conclusion that I can ignore the details so long as there are many steps is the following:&lt;/p&gt;
&lt;p&gt;We can model the error introduced by each step as a random variable. Let's assume that each step is independent of the others. The result of camera readout is a sum of a large number of independent random variables. And of course the &lt;a href="https://en.wikipedia.org/wiki/Central_limit_theorem"&gt;Central Limit Theorem&lt;/a&gt; states that the distribution of the sum of random variables tends towards a normal distribution, i.e. Gaussian, as the number of random variables tends towards infinity. This happens regardless of the distributions of the underlying random variables.&lt;/p&gt;
&lt;p&gt;So read noise can appear to be effectively Gaussian so long as there are many steps along the path of conversion from photoelectrons to pixel values and each step has a chance of introducing an error.&lt;/p&gt;
&lt;h3&gt;Sums of Discrete Random Variables&lt;/h3&gt;
&lt;p&gt;I encountered one conceptual difficulty here: the sum of discrete random variables is still discrete. If I have several variables that produce only integers, their sum is still an integer. I cannot get, say, 3.14159 as a result. Does the Gaussian approximation, which is for continuous random variables, still apply in this case?&lt;/p&gt;
&lt;p&gt;This question is relevant because the signal in a camera is transformed between discrete a continuous representations at least twice: from electrons to voltage and from voltage to analog-to-digital units (ADUs).&lt;/p&gt;
&lt;p&gt;Let's say that I have a discrete random variable that can assume values of 0 or 1, and the probability that the value is 1 is denoted \( p \). This is known as a Bernoulli trial. Now let's say that I have a large number \( n \) of Bernoulli trials. But the sum of \( n \) Bernoulli trials has a distribution that is binomial, and this is well-known to be approximated as a Gaussian when certain conditions are met, including large \( n \)&lt;sup id="fnref:4"&gt;&lt;a class="footnote-ref" href="https://kylemdouglass.com/posts/why-is-camera-read-noise-gaussian-distributed/#fn:4"&gt;4&lt;/a&gt;&lt;/sup&gt;. So a sum of a large number of discrete random variables can have a probability distribution function that is approximated as a Gaussian.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;This does not mean that the sum of discrete random variables can take on continuous values.&lt;/strong&gt; Rather, the probability associated with any one output value can be estimated by a Gaussian probability density function.&lt;/p&gt;
&lt;p&gt;But how exactly can I use a continuous distribution to approximate a discrete one? After all, if the random variable \( Y \) is a continuous, Gaussian random variable, then \(P (Y = a)  = 0 \) for all values of \( a \). To get a non-zero probability from a probability density function, I need to integrate it over some interval of its domain. We can therefore integrate the Gaussian in a small interval around each possible value of the discrete random variable, and then associate this integrated area with the probability of the obtaining that discrete value. This is called a &lt;a href="https://en.wikipedia.org/wiki/Continuity_correction"&gt;continuity correction&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;Example of a Continuity Correction&lt;/h4&gt;
&lt;p&gt;As a very simple example, consider a discrete random variable \( X \) that is approximated by a Gaussian continuous random variable \( Y \). The probability of getting a discrete value 5 is \( P (X = 5) \). The Gaussian approximation is \( P ( 4.5 \lt Y \lt 5.5 ) \), i.e. we integrate the Gaussian from 4.5 to 5.5 to compute the approximate probability of getting the discrete value 5.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;I wrote a blog post about this a while back: &lt;a href="https://kmdouglass.github.io/posts/modeling-noise-for-image-simulations/"&gt;https://kmdouglass.github.io/posts/modeling-noise-for-image-simulations/&lt;/a&gt; &lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/why-is-camera-read-noise-gaussian-distributed/#fnref:1" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;This is often asserted without justification. See for example Janesick, Photon Transfer, page 34. &lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/why-is-camera-read-noise-gaussian-distributed/#fnref:2" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;&lt;a href="https://doi.org/10.1117/3.725073"&gt;https://doi.org/10.1117/3.725073&lt;/a&gt; &lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/why-is-camera-read-noise-gaussian-distributed/#fnref:3" title="Jump back to footnote 3 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:4"&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Binomial_distribution#Normal_approximation"&gt;https://en.wikipedia.org/wiki/Binomial_distribution#Normal_approximation&lt;/a&gt; &lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/why-is-camera-read-noise-gaussian-distributed/#fnref:4" title="Jump back to footnote 4 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><category>cameras</category><category>microscopy</category><category>statistics</category><guid>https://kylemdouglass.com/posts/why-is-camera-read-noise-gaussian-distributed/</guid><pubDate>Thu, 19 Jun 2025 08:40:12 GMT</pubDate></item><item><title>3D Sequential Optical System Layouts</title><link>https://kylemdouglass.com/posts/3d-sequential-optical-system-layouts/</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;p&gt;I am working on a new feature in my &lt;a href="https://github.com/kmdouglass/cherry"&gt;ray tracer&lt;/a&gt; that will allow users to lay out sequential optical systems in 3D. This is forcing me to think carefully about 3D rigid body transformations in a level of detail that I have never before considered.&lt;/p&gt;
&lt;p&gt;In this post I walk through the mathematics for modeling a pair of flat mirrors that are oriented at different angles. Strictly speaking, the layout can be represented more easily in 2D, but I will treat the problem as if it were the more general 3D case. Emphasis will be placed on specifying rotations in an intuitive manner, which will mean rotations about the optical axis, rather than about a fixed axis in a global reference frame.&lt;/p&gt;
&lt;h2&gt;The Problem&lt;/h2&gt;
&lt;p&gt;The problem that I will consider is depicted as follows:&lt;/p&gt;
&lt;p&gt;&lt;img alt="A system of two flat mirrors whose optical axis forms the figure Z." src="https://kylemdouglass.com/images/sequential-layout-problem-statement.png"&gt;&lt;/p&gt;
&lt;p&gt;The system consists of two flat mirrors whose optical axis forms a "figure Z." The normal of the first mirror is at 30 degrees to the axis, and likewise for the second. The optical axis emerges from the second mirror parallel to the first.&lt;/p&gt;
&lt;p&gt;The questions are:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;How do I construct the system without requiring the user to specify the absolute coordinates of the mirror surfaces?&lt;/li&gt;
&lt;li&gt;How do I represent the local coordinate reference frames for each mirror surface?&lt;/li&gt;
&lt;li&gt;How do I handle transformations between frames?&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Ray Tracing Review&lt;/h3&gt;
&lt;p&gt;As a quick review, the ray tracing algorithm that I implemented was described by Spencer and Murty&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="https://kylemdouglass.com/posts/3d-sequential-optical-system-layouts/#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;. It is loosely follows this pseudo-code:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;each&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;surface&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;system&lt;/span&gt;:
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;each&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;ray&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;ray&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;bundle&lt;/span&gt;:
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;.&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;transform&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;ray&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;coordinates&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;by&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;rotating&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;reference&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;frame&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;into&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;local&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;surface&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;frame&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;.&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;find&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;ray&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;surface&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;intersection&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;point&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;.&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;propagate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;ray&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;to&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;intersection&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;point&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;.&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;perform&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;bounds&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;checking&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;against&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;surface&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;.&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;redirect&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;ray&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;according&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;to&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;laws&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;of&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;refraction&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;reflection&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;.&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;transform&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;ray&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;coordinates&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;by&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;rotating&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;reference&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;frame&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;back&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;into&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;global&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;frame&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Rotations are performed using 3x3 rotation matrices. Ray/surface intersections are found numerically using the Newton-Raphson method, even for spherical surfaces&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="https://kylemdouglass.com/posts/3d-sequential-optical-system-layouts/#fn:2"&gt;2&lt;/a&gt;&lt;/sup&gt;. I computed the expressions for the surface sag and normal vectors for conics and flat surfaces by hand and hard-coded them as functions of the intersection point in the local surface reference frame to avoid having to compute them on-the-fly.&lt;/p&gt;
&lt;p&gt;Looking at the ray trace algorithm, I see three things that are relevant to this discussion:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;There are both global and local reference frames&lt;/li&gt;
&lt;li&gt;Surfaces are iterated over sequentially&lt;/li&gt;
&lt;li&gt;There are rotations, one at the beginning of each loop iteration and one at the end&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Let's explore each one individually, starting with the global and local reference frames.&lt;/p&gt;
&lt;h2&gt;Reference Frames&lt;/h2&gt;
&lt;p&gt;I will use only right-handed reference frames where positive rotations are in the counterclockwise direction.&lt;/p&gt;
&lt;h3&gt;The Global Reference Frame&lt;/h3&gt;
&lt;p&gt;The global reference frame \( \mathbf{G} \) remains fixed. Sometimes it's called the world frame. I denote the coordinate axes of the global frame using \( x \), \( y \), and \( z \).&lt;/p&gt;
&lt;p&gt;&lt;img alt="The global reference frame." src="https://kylemdouglass.com/images/sequential-layout-global-reference-frame.png"&gt;&lt;/p&gt;
&lt;p&gt;By convention, I put its origin at the first non-object surface; this would be at the first mirror in the system of two mirrors I described above&lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="https://kylemdouglass.com/posts/3d-sequential-optical-system-layouts/#fn:3"&gt;3&lt;/a&gt;&lt;/sup&gt;. I also establish the convention that the optical axis between the object and the first surface is parallel to the global z-axis.&lt;/p&gt;
&lt;p&gt;The global frame is important because the orthonormal vectors defining the local and cursor frames (to be explained later) are expressed relative to it.&lt;/p&gt;
&lt;h3&gt;Local Reference Frames&lt;/h3&gt;
&lt;p&gt;Each surface \( i \) has a local reference frame \( \mathbf{L}_i \) whose origin lies at the vertex of the surface. Its coordinate axes are denoted \( x_i^{\prime} \), \( y_i^{\prime} \), and \( z_i^{\prime} \). For flat surfaces, I set the \( z_i^{\prime} \) axis perpendicular to the surface.&lt;/p&gt;
&lt;p&gt;&lt;img alt="The local reference frames of the two mirrors." src="https://kylemdouglass.com/images/sequential-layout-local-reference-frames.png"&gt;&lt;/p&gt;
&lt;p&gt;Notice that the \( x^{\prime} \) axes flip directions when going from mirror 1 to mirror 2. This is done to preserve the right-handedness of the reference frames. More about this will be explained in the next section.&lt;/p&gt;
&lt;h2&gt;Sequential System Models&lt;/h2&gt;
&lt;p&gt;Ray tracing programs for optical design are often divided into two categories: sequential and nonsequential. In sequential ray tracers, rays are traced from one surface to another in the sequence for which they are defined. This means that a ray could pass right through a surface if it is not the next surface in the model sequence.&lt;/p&gt;
&lt;p&gt;Nonsequential ray tracers do not take account of the order in which surfaces are defined. Rays are fired into the world and the intersect whatever the closest object is on their path. Illumination optics often use nonsequential ray tracing, as do rendering engines for cinema.&lt;/p&gt;
&lt;p&gt;My ray tracer is a sequential ray tracer because sequential ray tracing is easier to implement and can be applied to nearly all the use cases that I encounter in the lab.&lt;/p&gt;
&lt;h3&gt;3D Layouts of Sequential Surfaces&lt;/h3&gt;
&lt;p&gt;One possibility to layout sequential surfaces in 3D is to specify the coordinates and orientations of each surface relative to the global frame. This is how one adds surfaces in 3D in the open source Python library &lt;a href="https://github.com/HarrisonKramer/optiland"&gt;Optiland&lt;/a&gt;, for example. In practice, I found that I need to have a piece of paper by my side to work out the positions of each surface independently. This option provides maximum flexibility in surface placement.&lt;/p&gt;
&lt;p&gt;The other possibility that I considered is to leverage the fact that the surfaces are an ordered sequence, and position them in 3D space along the optical axis. The axis can reflect from reflecting surfaces using the law of reflection. Furthermore, any tilt or decenter could be specified relative to this axis. I ultimately chose this solution because I felt that it better matches my mental model of sequential optical systems. It also seems to follow more closely what I do in the lab when I build a system, i.e. add components along an axis that bends through 3D space.&lt;/p&gt;
&lt;h3&gt;The Cursor&lt;/h3&gt;
&lt;p&gt;I created the idea of the cursor to position sequential surfaces in 3D space. A cursor has a 3D position, \( \vec{ t } \left( s \right) \) that is parameterized over the track length \( s \). \( s \) is negative for the object surface, \( s = 0 \) at the first non-object surface, and achieves its greatest value at the final image plane.&lt;/p&gt;
&lt;p&gt;In addition, the cursor has a reference frame attached to it that I denote \( \mathbf{C} \left( s \right) \). The axes of the cursor frame are \( r \), \( u \)  and \( f \), which stand for right, up, and forward, respectively. This nearly matches the &lt;a href="https://dev.epicgames.com/documentation/en-us/uefn/forwardrightup-coordinate-system-in-unreal-editor-for-fortnite"&gt;FRU&lt;/a&gt; coordinate system in game engines such as Unreal, except I take the forward direction to represent the optical axis because I would say that this convention is universal in optical design.&lt;/p&gt;
&lt;p&gt;&lt;img alt="The cursor frames at three different positions along the optical axis." src="https://kylemdouglass.com/images/sequential-layout-cursor-frames.png"&gt;&lt;/p&gt;
&lt;p&gt;Above I show the cursor frame at three different positions along the optical axis \( s_1 &amp;lt; 0 &amp;lt; s_2 &amp;lt; s_3 \). Refracting surfaces will not change the orientation of the cursor frame, but reflecting surfaces will.&lt;/p&gt;
&lt;p&gt;Finally, when \( s \) is exactly equal to a reflecting surface position, I take the orientation of the cursor frame to be the one &lt;strong&gt;before&lt;/strong&gt; reflection. An infinitesimal distance later, the frame reorients by reflecting about the surface normal at the vertex of the surface in its local frame.&lt;/p&gt;
&lt;h4&gt;Convention for Maintaining Right Handedness upon Reflection&lt;/h4&gt;
&lt;p&gt;There is an ambiguity that arises in the cursor frame upon reflection that is best illustrated in the example below:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Ambiguity in the cursor frame upon reflection." src="https://kylemdouglass.com/images/sequential-layout-ambiguity.png"&gt;&lt;/p&gt;
&lt;p&gt;In panel a, the cursor is incident upon a mirror with its frame's forward direction antiparallel to the mirror's normal vector. There are two equally valid choices when defining the cursor frame after reflection. In panel b, the cursor frame is rotated about the up direction, whereas in panel c it is rotated about the right direction. This means that there is no fundamentally correct way to position the cursor frame after reflection. We must choose a convention and stick with it.&lt;/p&gt;
&lt;p&gt;Reflections of the cursor frame are handled in two steps:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Reflect the frame&lt;/li&gt;
&lt;li&gt;Adjust the results to maintain right handedness and address the ambiguity illustrated above&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The vector law of reflection is used to compute the new \( \hat{ r } \), \( \hat{ u } \), and \( \hat{ f } \) unit vectors for any general angle of incidence of the cursor frame upon a reflecting surface:&lt;/p&gt;
&lt;p&gt;$$\begin{equation}
\hat{ f }^{\prime} = \hat{ f } - 2 \left( \hat{ f } \cdot \hat{ n } \right) \hat{ n }
\end{equation}$$&lt;/p&gt;
&lt;p&gt;where \( \hat{ n } \) is the surface's unit normal vector. The same applies for the right and up unit vectors.&lt;/p&gt;
&lt;p&gt;After reflection, I perform a check for right handedness. By convention, I maintain the direction of the up unit vector because many optical systems are laid out in 2D and their elements are rotated about this direction. This convention means that the right unit vector must be flipped:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;cross&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;right&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;up&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;·&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;forward&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;:
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nv"&gt;right&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;right&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The cross product between the right and up directions must point in the forward direction if the system is right handed. "Pointing in the forward direction" means that the dot product of the result with the forward unit vector must be greater than zero. The conditonal in the pseudocode above checks whether this is not indeed the case and flips the right unit vector if necessary.&lt;/p&gt;
&lt;h2&gt;Transformations between Reference Frames&lt;/h2&gt;
&lt;p&gt;There are two different transformations required by the ray trace algorithm:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;From the global frame to a surface local frame&lt;/li&gt;
&lt;li&gt;From a surface local frame to the global frame&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Because the system is laid out relative to the cursor frame, I need to chain together two rotations, one from the global to the cursor frame, and one from the cursor to the local frame.&lt;/p&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;p&gt;Let's say that the second mirror has a diameter of 25.4 mm, and that the mirrors are separated by \( \| \vec{ t } \left( s_2 \right) \| = 100 \, mm \). I want to find the transformation from the global frame coordinates at a point on the bottom edge of the mirror to the local frame coordinates, which is \( y_2^{\prime} = -12.7 \, mm \). The image below illustrates the geometry that will be used for this example.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Example geometry for transforming from the global frame to the local frame via the cursor frame." src="https://kylemdouglass.com/images/sequential-layout-example-geometry.png"&gt;&lt;/p&gt;
&lt;p&gt;From relatively straightforward trigonmetry&lt;sup id="fnref:4"&gt;&lt;a class="footnote-ref" href="https://kylemdouglass.com/posts/3d-sequential-optical-system-layouts/#fn:4"&gt;4&lt;/a&gt;&lt;/sup&gt; we get the global frame coordinates of both \( {}^{\mathbf{G}}\vec{ t } \left( s_2 \right) \) and the point we are trying to find, \( {}^{\mathbf{G}}\vec{ p } \). (Vectors preceded by superscripts with reference frame names indicate the coordinate system they are being referred to.)&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
 {}^{\mathbf{G}}\vec{ t } \left( s_2 \right) = \left(
  \begin{array}{c}
    0 \\
    50 \sqrt{ 3 } \\
    -50
  \end{array}
\right)
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
 {}^{\mathbf{G}}\vec{ p } = \left(
  \begin{array}{c}
    0 \\
    43.65 \sqrt{ 3 } \\
    -56.35
  \end{array}
\right)
\end{eqnarray}$$&lt;/p&gt;
&lt;h4&gt;Step 1: Translate from the Global Origin to the Cursor Frame&lt;/h4&gt;
&lt;p&gt;The first step in computing \( {}^{\mathbf{ C }} \vec{ p } \) is to translate from the origin of the global frame to the position of cursor.&lt;/p&gt;
&lt;p&gt;$$ {}^{\mathbf{G}}\vec{ p } - {}^{\mathbf{G}}\vec{ t } \left( s_2 \right)  =  (0, -6.35 \sqrt{3}, -6.35)^{ \mathrm{ T }}$$&lt;/p&gt;
&lt;h4&gt;Step 2: Rotate into the Cursor Frame&lt;/h4&gt;
&lt;p&gt;A rotation from the global frame into the cursor frame can be achieved by taking the \( \hat{ r } \), \( \hat{ u } \), and \( \hat{ f } \) unit vectors that define the cursor frame in the global coordinate system and making them the columns of a \( 3 \times 3 \) rotation matrix. At the second mirror, this matrix is:&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
R_{GC} \left( \theta = 30^{ \circ } \right) = \left(
  \begin{array}{ccc}
    -1 &amp;amp; 0 &amp;amp; 0 \\
    0 &amp;amp; 1 / 2 &amp;amp; \sqrt{ 3 } / 2 \\
    0 &amp;amp; \sqrt{ 3 } / 2 &amp;amp; -1 / 2
  \end{array}
\right)
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;If this is not clear, consider that the columns of a rotation matrix represent the basis vectors of the coordinate system after rotation, but expressed in the original (global) frame's coordinate system. Also, from the diagram above, \( \hat{ u } \left( s_2 \right) = ( 0, 1 / 2, \sqrt{ 3 } / 2)^{ \mathrm{ T }} \) and \( \hat{ f } \left( s_2 \right) = ( 0, \sqrt{ 3 } / 2, - 1 / 2)^{ \mathrm{ T }}\), which are the second and third columns of the matrix.&lt;/p&gt;
&lt;p&gt;The rotation into the cursor frame is the product between the rotation matrix and the difference \( {}^{\mathbf{G}}\vec{ p } - {}^{\mathbf{G}}\vec{ t } \left( s_2 \right) \):&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
{}^{\mathbf{ C }} \vec{ p } = R_{GC} \left[ {}^{\mathbf{G}}\vec{ p } - {}^{\mathbf{G}}\vec{ t } \left( s_2 \right) \right] = \left(
  \begin{array}{ccc}
    -1 &amp;amp; 0 &amp;amp; 0 \\
    0 &amp;amp; 1 / 2 &amp;amp; \sqrt{ 3 } / 2 \\
    0 &amp;amp; \sqrt{ 3 } / 2 &amp;amp; -1 / 2
  \end{array}
\right) \left(
  \begin{array}{c}
    0 \\
    -6.35 \sqrt{ 3 } \\
    -6.35
  \end{array}
\right) = \left(
  \begin{array}{c}
    0 \\
    -6.35 \sqrt{ 3 } \\
    -6.35
  \end{array}
\right)
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;At first, I thought I had made a mistake when I did this calculation because the vector is unchanged after rotation. However, as illustrated below, you can see that the relative lengths of the projections of \( {}^{\mathbf{G}}\vec{ p } - {}^{\mathbf{G}}\vec{ t } \left( s_2 \right) \) onto the \( u \) and \( f \) axes make sense.&lt;/p&gt;
&lt;p&gt;&lt;img alt="A simplified schematic showing the projection of difference vector onto the -u and -f axes." src="https://kylemdouglass.com/images/sequential-layout-example-global-to-cursor.png"&gt;&lt;/p&gt;
&lt;p&gt;As it turns out, I inadvertently chose an eigenvector of the rotation matrix as an example; any general point will in fact change its coordinates when moving from the global to the cursor frame. For example, if we try to rotate a vector that is antiparallel to the global z-axis, i.e. \( {}^{\mathbf{G}}\vec{ p } - {}^{\mathbf{G}}\vec{ t } \left( s_2 \right) = ( 0, 0, -1 )^{ \mathrm{ T } }\), then it will become&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
R_{GC} \left[ {}^{\mathbf{G}}\vec{ p } - {}^{\mathbf{G}}\vec{ t } \left( s_2 \right) \right] = \left(
  \begin{array}{ccc}
    -1 &amp;amp; 0 &amp;amp; 0 \\
    0 &amp;amp; 1 / 2 &amp;amp; \sqrt{ 3 } / 2 \\
    0 &amp;amp; \sqrt{ 3 } / 2 &amp;amp; -1 / 2
  \end{array}
\right) \left(
  \begin{array}{c}
    0 \\
    0 \\
    -1
  \end{array}
\right) = \left(
  \begin{array}{c}
    0 \\
    -0.8660 \\
    -0.5
  \end{array}
\right)
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;in the cursor frame.&lt;/p&gt;
&lt;h4&gt;Step 3: Rotate into the Surface Local Frame&lt;/h4&gt;
&lt;p&gt;For the final step, I need to compose a rotation matrix from a sequence of three rotations. To do this well, I need to be very clear about what types of rotations I am performing and their sequence.&lt;/p&gt;
&lt;h5&gt;Active vs. Passive Rotations&lt;/h5&gt;
&lt;p&gt;The difference between active and passive rotations are illustrated below for a 45 degree rotation about the right axis.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Active vs. passive rotations" src="https://kylemdouglass.com/images/sequential-layout-active-vs-passive.png"&gt;&lt;/p&gt;
&lt;p&gt;Active rotations specify the rotation of a point relative to a fixed reference frame; passive rotations specify the rotation of a reference frame, keeping the point fixed. And pay attention here: the right axis points into the screen, so a positive rotation would be clockwise when viewed from the perspective drawn above. &lt;/p&gt;
&lt;p&gt;What are the corresponding rotation matrices? Here, I found that the internet is absolutely littered with wrong answers, including on sites like Wikipedia. I even get different answers from LLMs depending on when I ask. Therefore, I am including them here as a gift to my future self.&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;active&lt;/strong&gt; rotation matrices about the x (right), y (up), and z (forward) axes are:&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
R_x \left( \theta \right) = \left(
  \begin{array}{ccc}
    1 &amp;amp; 0 &amp;amp; 0 \\
    0 &amp;amp; \cos \theta &amp;amp; - \sin \theta \\
    0 &amp;amp; \sin \theta &amp;amp; \cos \theta
  \end{array}
\right)
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
R_y \left( \psi \right) = \left(
  \begin{array}{ccc}
    \cos \psi &amp;amp; 0 &amp;amp; \sin \psi \\
    0 &amp;amp; 1 &amp;amp; 0 \\
    - \sin \psi &amp;amp; 0 &amp;amp; \cos \psi
  \end{array}
\right)
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
R_z \left( \phi \right) = \left(
  \begin{array}{ccc}
    \cos \phi &amp;amp; - \sin \phi &amp;amp; 0 \\
    \sin \phi &amp;amp; \cos \phi &amp;amp; 0 \\
    0 &amp;amp; 0 &amp;amp; 1
  \end{array}
\right)
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;passive&lt;/strong&gt; rotation matrices about the x (right), y (up), and z (forward) axes are:&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
R_x \left( \theta \right) = \left(
  \begin{array}{ccc}
    1 &amp;amp; 0 &amp;amp; 0 \\
    0 &amp;amp; \cos \theta &amp;amp; \sin \theta \\
    0 &amp;amp; - \sin \theta &amp;amp; \cos \theta
  \end{array}
\right)
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
R_y \left( \psi \right) = \left(
  \begin{array}{ccc}
    \cos \psi &amp;amp; 0 &amp;amp; - \sin \psi \\
    0 &amp;amp; 1 &amp;amp; 0 \\
    \sin \psi &amp;amp; 0 &amp;amp; \cos \psi
  \end{array}
\right)
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
R_z \left( \phi \right) = \left(
  \begin{array}{ccc}
    \cos \phi &amp;amp; \sin \phi &amp;amp; 0 \\
    - \sin \phi &amp;amp; \cos \phi &amp;amp; 0 \\
    0 &amp;amp; 0 &amp;amp; 1
  \end{array}
\right)
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;Notice that all that changes between these two types of rotations is the location of a negative sign on the \( \sin \) terms.&lt;/p&gt;
&lt;p&gt;I found that a useful way to remember whether a matrix represents an active or passive rotation is as follows. Take for example the +45 degree rotation of the vector \( ( 0, 0, 1 )^{ \mathrm{ T } } \) about the right direction illustrated above. You can see that an active rotation should result in a negative \( u \) and a positive \( f \) component. This means&lt;sup id="fnref:6"&gt;&lt;a class="footnote-ref" href="https://kylemdouglass.com/posts/3d-sequential-optical-system-layouts/#fn:6"&gt;6&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
\left(
  \begin{array}{ccc}
    1 &amp;amp; 0 &amp;amp; 0 \\
    0 &amp;amp; 1 / \sqrt{ 2 } &amp;amp; - 1 / \sqrt{ 2 } \\
    0 &amp;amp; 1 / \sqrt{ 2 } &amp;amp; 1 / \sqrt{ 2 }
  \end{array}
\right) \left(
  \begin{array}{c}
    0 \\
    0 \\
    1
  \end{array}
\right) = \left(
  \begin{array}{c}
    0 \\
    - 1 / \sqrt{ 2 } \\
    1 / \sqrt{ 2 }
  \end{array}
\right)
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;The passive rotation should result in positive values for both the \( u^{ \prime } \) and \( f^{ \prime } \) components:&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
\left(
  \begin{array}{ccc}
    1 &amp;amp; 0 &amp;amp; 0 \\
    0 &amp;amp; 1 / \sqrt{ 2 } &amp;amp; 1 / \sqrt{ 2 } \\
    0 &amp;amp; - 1 / \sqrt{ 2 } &amp;amp; 1 / \sqrt{ 2 }
  \end{array}
\right) \left(
  \begin{array}{c}
    0 \\
    0 \\
    1
  \end{array}
\right) = \left(
  \begin{array}{c}
    0 \\
    1 / \sqrt{ 2 } \\
    1 / \sqrt{ 2 }
  \end{array}
\right)
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;I can do a similar check for the other directions to verify the other matrices.&lt;/p&gt;
&lt;h5&gt;Extrinsic vs. Intrinsic Rotations&lt;/h5&gt;
&lt;p&gt;I found these easier to understand than active and passive rotations. Extrinsic rotations are rotations that are always about a fixed global reference frame. On the other hand, intrinsic rotations are about the intermediate frames that result from a single rotation. So if I rotate about the \( f \) axis, then the \( r \) and \( u \) axes will be rotated, resulting in an intermediate \( r^{ \prime }u^{ \prime }f^{ \prime } \) frame. The next rotation will be about one of these intermediate axes.&lt;/p&gt;
&lt;p&gt;The confusing thing about these two types of rotations is the order in which the rotation matrices are applied to a vector. An &lt;strong&gt;extrinsic&lt;/strong&gt; rotation of a vector \( \vec{ v } \) about \( r \), then \( u \), then \( f \) is written as:&lt;/p&gt;
&lt;p&gt;$$ R_f R_u R_r \vec{ v} $$&lt;/p&gt;
&lt;p&gt;which follows the usual commutativity rules of matrix multiplication. An &lt;strong&gt;intrinsic&lt;/strong&gt; rotation of a vector \( \vec{ v } \) about \( r \), then \( u^{ \prime } \), then \( f^{ \prime \prime } \), on the other hand is written as:&lt;/p&gt;
&lt;p&gt;$$ R_r R_u R_f \vec{ v} $$&lt;/p&gt;
&lt;p&gt;So even though the rotation about the right direction is performed first, we multiply the vector first by the rotation matrix about the \( f \) direction in the second intermediate frame.&lt;/p&gt;
&lt;p&gt;All of this might seem confusing and lead one to wonder why they would want to use intrinsic rotations, but actually they are much more intuitive than extrinsic rotations and make a lot of sense when laying out an optical system. For example, if I have a two-axis mirror mount and I rotate the mirror about the vertical axis, a horizontal rotation that follows will be about the axis in the newly rotated frame, not the global laboratory frame. In any case, a sequence of three extrinsic rotations and three intrinsic rotations through the same angles will produce the same result so long as the order of the rotation matrices is correct.&lt;/p&gt;
&lt;h5&gt;Euler Angles and Rotation Sequences&lt;/h5&gt;
&lt;p&gt;The most important thing I learned about Euler angles is that they are completely meaningless unless you also specify a rotation sequence. Additionally, the internet is full of resources about the distinction between proper and improper Euler angles. The gist of what I learned here is that proper Euler angles are really a distraction to scientists and engineers because they rely on rotation sequences in which one of the axes is used twice. More useful are what aerospace engineers sometimes refer to as the Tait-Bryan angles, which are the rotation angles associated with sequences like \( z-y^{ \prime }-x^{ \prime \prime } \) or \( x-y-z \).&lt;/p&gt;
&lt;p&gt;Now, there is one point here that is worth making and that is relevant to optical system layout: &lt;strong&gt;rotations about \( f \), the forward direction, into the local frame are best performed last in the sequence.&lt;/strong&gt; To understand why, consider a cylindrical lens with an axis parallel to the local \( z' \) direction. If we perform an intrinsic rotation about the cursor's \( f \) direction first and then try to adjust its tip or tilt, we will be doing so about axes that are rotated such that its tip and tilt become coupled with respect to the global frame. When aligning such systems, no one expects that rotation of a cylindrical lens about its axis will change the way that the tip and tilt adjustors on a lens mount work.&lt;/p&gt;
&lt;p&gt;For all these reasons, I choose an intrinsic sequence \(r - u^{ \prime } - f^{{ \prime \prime} } \) of passive rotations with Euler angles \( \theta \), \( \psi \), and \( \phi \), respectively. The corresponding rotation matrix is:&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
R_{ \mathbf{ CL } } ( \theta, \psi, \phi ) = R_r ( \theta ) R_u ( \psi ) R_f ( \phi ) = \left(
  \begin{array}{ccc}
    \cos \phi \cos \psi &amp;amp; \sin \phi \cos \psi &amp;amp; - \sin \psi \\
    - \sin \phi \cos \theta + \sin \psi \sin \theta \cos \phi &amp;amp; \sin \phi \sin \psi \sin \theta + \cos \phi \cos \theta &amp;amp; \sin \theta \cos \psi \\
    \sin \phi \sin \theta + \sin \psi \cos \phi \cos \theta &amp;amp; \sin \phi \sin \psi \cos \theta - \sin \theta \cos \phi &amp;amp; \cos \psi \cos \theta 
  \end{array}
\right)
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;And finally, the transformation of the point on the mirror from the global to the surface local frame is:&lt;/p&gt;
&lt;p&gt;$$ {}^{ \mathbf{ L }}\vec{p} = R_{ CL }R_{ GC } \left[ {}^{\mathbf{G}}\vec{ p } - {}^{\mathbf{G}}\vec{ t } \left( s_2 \right) \right] $$&lt;/p&gt;
&lt;h5&gt;The Solution to the Example&lt;/h5&gt;
&lt;p&gt;Does this give the correct result in the above example? Well, the mirror is rotated +30 degrees about the right direction, so the cursor-to-local rotation matrix is:&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
R_{CL} \left( \theta  = 30^{ \circ },  \psi = 0, \phi = 0 \right) = \left(
  \begin{array}{ccc}
    1 &amp;amp; 0 &amp;amp; 0 \\
    0 &amp;amp; \sqrt{ 3 } / 2 &amp;amp; 1 / 2 \\
    0 &amp;amp; - 1 / 2 &amp;amp; \sqrt{ 3 } / 2
  \end{array}
\right)
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;From earlier, the vector representing the point in the cursor frame is \( ( 0, -6.35 \sqrt{ 3 }, -6.35 )^{ \mathrm{ T } } \). Their product gives the final answer:&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
{}^{ \mathbf{ L } }\vec{ p } = \left(
  \begin{array}{ccc}
    1 &amp;amp; 0 &amp;amp; 0 \\
    0 &amp;amp; \sqrt{ 3 } / 2 &amp;amp; 1 / 2 \\
    0 &amp;amp; - 1 / 2 &amp;amp; \sqrt{ 3 } / 2
  \end{array}
\right) \left(
  \begin{array}{c}
    0 \\
    -6.35 \sqrt{ 3 } \\
    -6.35
  \end{array}
\right) = \left(
\begin{array}{c}
    0 \\
    -12.7 \\
    0
  \end{array}
\right)
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;This is exactly as expected, as we wanted to get a point on the bottom of the 25.4 mm diameter mirror in its local frame.&lt;/p&gt;
&lt;h4&gt;Step 4: Rotate back from the Surface Local to the Global Frame&lt;/h4&gt;
&lt;p&gt;I need to go back to the global frame at the end of each iteration for a ray trace. Fortunately, it's easy to undo a rotation because the inverse of a rotation matrix is just its transpose. I also need to swap the order of the matrices when taking the inverse, and add back the offset from the origin of the global system. This means:&lt;/p&gt;
&lt;p&gt;$${}^{\mathbf{ G } }\vec{ p } = R_{GC}^{ \mathrm{ T} } R_{CL}^{ \mathrm{ T} } {}^{\mathbf{ L } }\vec{ p } + {}^{\mathbf{ G }} \vec{ t } (s_2) $$&lt;/p&gt;
&lt;p&gt;I plugged in the numbers in Python and verified that I get the original point back.&lt;/p&gt;
&lt;p&gt;This should be all I need to know to implement 3D sequential optical system layouts in my ray tracer.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;G. H. Spencer and M. V. R. K. Murty, "General Ray-Tracing Procedure," J. Opt. Soc. Am. 52, 672-678 (1962). &lt;a href="https://doi.org/10.1364/JOSA.52.000672"&gt;https://doi.org/10.1364/JOSA.52.000672&lt;/a&gt;. &lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/3d-sequential-optical-system-layouts/#fnref:1" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;Ray/surface intersections with spherical surfaces can be found analytically using the quadratic equation with only minor caveats considering stability issues due to floating point arithmetic. This would likely be faster than using Newton-Raphson. However, a general system contains both spherical and non-spherical surfaces, and I was concerned that checking each surface type would result in a performance hit due to branch prediction failures by the processor. I could probably have found a way around this by deciding ahead of time which algorithm to use to determine the intersection for each surface before entering the main ray tracing loop, but during initial development I decided to just use Newton-Raphson for everything because doing so resulted in very simple code. (Thanks to Andy York for telling me about the numerical instabilities when using the quadratic equation. See Chapter 7 here: &lt;a href="https://www.realtimerendering.com/raytracinggems/rtg/index.html"&gt;https://www.realtimerendering.com/raytracinggems/rtg/index.html&lt;/a&gt;.) &lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/3d-sequential-optical-system-layouts/#fnref:2" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;The object plane is the flat surface perpendicular to the optical axis in which the object lies. It is always at surface index 0 in my convention. &lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/3d-sequential-optical-system-layouts/#fnref:3" title="Jump back to footnote 3 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:4"&gt;
&lt;p&gt;Since the only angles involved are \( 30^{ \circ} \) and \( 60^{ \circ } \), I used a 30-60-90 triangle of lengths 1, \( \sqrt{ 3 } \), and 2, respectively to compute the cosines and sines. &lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/3d-sequential-optical-system-layouts/#fnref:4" title="Jump back to footnote 4 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:5"&gt;
&lt;p&gt;Passive rotations result in a rotation of the coordinate axes, keeping a point fixed; active rotations rotate a point about a set of axes. &lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/3d-sequential-optical-system-layouts/#fnref:5" title="Jump back to footnote 5 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:6"&gt;
&lt;p&gt;The cosine and sine of 45 degrees are both \( 1 / \sqrt{ 2 } \). &lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/3d-sequential-optical-system-layouts/#fnref:6" title="Jump back to footnote 6 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><category>optics</category><category>ray tracing</category><guid>https://kylemdouglass.com/posts/3d-sequential-optical-system-layouts/</guid><pubDate>Thu, 05 Jun 2025 09:26:25 GMT</pubDate></item><item><title>A Very Brief Summary of The Analytic Signal in Fourier Optics</title><link>https://kylemdouglass.com/posts/a-very-brief-summary-of-the-analytic-signal-in-fourier-optics/</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;h2&gt;The Analytic Signal Representation of a Monochromatic Wave&lt;/h2&gt;
&lt;h3&gt;Monochromatic Scalar Waves&lt;/h3&gt;
&lt;p&gt;A monochromatic, scalar waveform is described by the expression:&lt;/p&gt;
&lt;p&gt;$$ u \left( \mathbf{r}, t\right) = A ( \mathbf{r} ) \cos \left[2 \pi f_0 t + \phi \left( \mathbf{r} \right) \right] $$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The signal is real-valued&lt;/li&gt;
&lt;li&gt;The signal has a known phase for all \( t \)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;The Analytic Signal&lt;/h3&gt;
&lt;p&gt;An analytic signal is a generalization of a phasor. It is used to represent a real-valued signal as a complex exponential or a sum of complex exponentials. When Goodman&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="https://kylemdouglass.com/posts/a-very-brief-summary-of-the-analytic-signal-in-fourier-optics/#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt; refers to a phasor, he often means the analytic signal. This is made clear in Chapter 6 where he describes the construction of the phasor for a narrowband signal as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;compute its Fourier transform&lt;/li&gt;
&lt;li&gt;set the positive frequency components to zero&lt;/li&gt;
&lt;li&gt;double the amplitudes of the negative frequency components&lt;/li&gt;
&lt;li&gt;inverse Fourier transform the resulting one-sided spectrum&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Strictly speaking, the analytic signal is obtained by setting the negative frequencies to zero and doubling by application of the Hilbert transform. However, many engineering fields have adopted the convention of setting the positive frequencies to zero instead. The results will be the same, except that the direction of power flow will be reversed (if I recall correctly).&lt;/p&gt;
&lt;p&gt;The Fourier transform of \( u \left( \mathbf{r}, t\right) \) is:&lt;/p&gt;
&lt;p&gt;$$ \mathcal{F} \left\{ u \left( \mathbf{r}, t\right) \right\} = \frac{A ( \mathbf{r} ) }{2} \left[ e^{j \phi \left( \mathbf{r} \right) } \delta \left( f - f_0 \right) + e^{-j \phi \left( \mathbf{r} \right) } \delta \left( f + f_0 \right) \right] $$&lt;/p&gt;
&lt;p&gt;Drop the positive frequency term \( e^{j \phi \left( \mathbf{r} \right) } \delta \left( f - f_0 \right) \) and double the result. This produces:&lt;/p&gt;
&lt;p&gt;$$ A ( \mathbf{r} ) e^{-j \phi \left( \mathbf{r} \right) } \delta \left( f + f_0 \right) $$&lt;/p&gt;
&lt;p&gt;Let \( U ( \mathbf{r} ) := A ( \mathbf{r} ) e^{-j \phi \left( \mathbf{r} \right) } \). The inverse Fourier transform of this signal is:&lt;/p&gt;
&lt;p&gt;$$ \mathcal{F}^{-1} \left\{ U ( \mathbf{r} ) \delta \left( f + f_0 \right) \right\} = U ( \mathbf{r} ) e^{-j 2 \pi f_0 t } $$&lt;/p&gt;
&lt;p&gt;We can recover the original field by taking the real part of this expression, which is equivalent to applying Euler's identity and dropping the imaginary part:&lt;/p&gt;
&lt;p&gt;$$ u \left( \mathbf{r}, t \right) = \Re \left[ U ( \mathbf{r} ) e^{-j 2 \pi f t} \right] $$&lt;/p&gt;
&lt;h2&gt;Polychromatic Scalar Waves&lt;/h2&gt;
&lt;p&gt;To model a polychromatic wave, we integrate over the analytic signals of each spectral component and take the real part of the result:&lt;/p&gt;
&lt;p&gt;$$ u \left( \mathbf{r}, t\right) = \Re \left[ \int_{-\infty}^{\infty} \tilde{U} \left( \mathbf{r}, f \right) e^{-j 2 \pi f t} \,df \right] $$&lt;/p&gt;
&lt;h3&gt;The Narrowband Assumption&lt;/h3&gt;
&lt;p&gt;We get a useful representation to the expression above if we assume that the bandwidth of the signal is much smaller than its center frequency \( \Delta f \ll f_0 \):&lt;/p&gt;
&lt;p&gt;$$ \int_{-\infty}^{\infty} \tilde{U} \left( \mathbf{r}, f \right) e^{-j 2 \pi f t} \,df = U \left( \mathbf{r}, t \right) e^{-j 2 \pi f_0 t} $$&lt;/p&gt;
&lt;p&gt;To better understand the meaning of this assumption, make the substitution \( \nu = f - f_0 \) into the expression on the left hand side:&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
\int_{-\infty}^{\infty} \tilde{U} \left( \mathbf{r}, f \right) e^{-j 2 \pi f t} \,df &amp;amp;=&amp;amp; \int_{-\infty}^{\infty} \tilde{U} \left( \mathbf{r}, \nu + f0 \right) e^{-j 2 \pi \left( \nu + f_0 \right) t} \,d\nu \\
&amp;amp;=&amp;amp; e^{-j 2 \pi f_0 t} \int_{-\infty}^{\infty} \tilde{U} \left( \mathbf{r}, \nu + f0 \right) e^{-j 2 \pi \nu t} \,d\nu
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;Under the narrowband assumption, the integration in the expression above is constrained to small values around \( \nu = 0 \) that are much less than the phasor term that is oscillating at frequency \( f_0 \). If we define the following function:&lt;/p&gt;
&lt;p&gt;$$ U \left( \mathbf{r}, t \right) := \int_{-\infty}^{\infty} \tilde{U} \left( \mathbf{r}, \nu + f0 \right) e^{-j 2 \pi \nu t} \,d\nu $$ &lt;/p&gt;
&lt;p&gt;then it will vary slowly with respect to the carrier frequency \( f_0 \).&lt;/p&gt;
&lt;p&gt;As a result, under the assumptions of narrowbandedness, we can interpret the complex function \( U \left( \mathbf{r}, t \right) \) as an "envelope" modulating the amplitude of the fast oscillating carrier wave. If the assumption is not valid, then this interpretation fails.&lt;/p&gt;
&lt;h3&gt;The Slowly Varying Envelope Assumption&lt;/h3&gt;
&lt;p&gt;It is instructive to reverse our reasoning and see why a slowly-varying envelope implies a narrowband signal. Compute the Fourier transforms of the narrowband waveform, along with the Fourier transform of the derivative of \( U \left( \mathbf{r}, t \right) \).&lt;/p&gt;
&lt;p&gt;The Fourier transform of the analytic signal:&lt;/p&gt;
&lt;p&gt;$$ \int_{-\infty}^{\infty} \left[ U \left( \mathbf{r}, t \right) e^{-j 2 \pi f_0 t} \right] e^{-j 2 \pi f t} \,dt = \tilde{U} \left( \mathbf{r}, f + f_0 \right) $$&lt;/p&gt;
&lt;p&gt;The Fourier transform of the derivative of \( U \):&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
\int_{-\infty}^{\infty} \frac{d}{dt} \left[ U \left( \mathbf{r}, t \right) \right] e^{-j 2 \pi f t} \,dt &amp;amp;=&amp;amp; j 2 \pi f \tilde{U} \left( \mathbf{r}, f \right)
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;Now, apply the &lt;a href="https://en.wikipedia.org/wiki/Slowly_varying_envelope_approximation"&gt;slowly varying envelope approximation (SVEA)&lt;/a&gt; by asserting that the rate of change of \( U \) with respect to time is much less than the value of \( U \) multiplied by the center frequency, or \( \left| \frac{d}{dt} U \left( \mathbf{r}, t\right) \right| \ll \left| 2 \pi f_0 U \left( \mathbf{r, t} \right) \right| \)&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
\left| j 2 \pi f \tilde{U} \left( \mathbf{r}, f \right) \right| &amp;amp;=&amp;amp; \left| \int_{-\infty}^{\infty} \frac{d}{dt} \left[ U \left( \mathbf{r}, t \right) \right] e^{-j 2 \pi f t} \,dt \right| \\
&amp;amp;\ll&amp;amp; \left| \int_{-\infty}^{\infty} 2 \pi f_0 U \left( \mathbf{r}, t \right) e^{-j 2 \pi f t} \,dt \right| \\
&amp;amp;\ll&amp;amp; 2 \pi f_0 \left| \tilde{U} \left( \mathbf{r}, f \right) \right|
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;This expression means that the appreciable frequency components of \( U \left( \mathbf{r} , t \right) \) are much less than the frequency \( f_0 \)&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="https://kylemdouglass.com/posts/a-very-brief-summary-of-the-analytic-signal-in-fourier-optics/#fn:2"&gt;2&lt;/a&gt;&lt;/sup&gt;. And when we consider the spectrum of \( U \left( \mathbf{r} , t \right) \) centered around \( f_0 \), we find that the bandwidth \( \Delta f \) is small with respect to \( f_0 \).&lt;/p&gt;
&lt;h3&gt;Assumptions, not Approximations!&lt;/h3&gt;
&lt;p&gt;The narrowband and slowly varying envelope assumptions are usually referred to as approximations. This is misleading! The resulting expression for the field is not an approximation at all; instead, under the assumptions of narrowbandedness, we can interpret the complex function \( U \left( \mathbf{r}, t \right) \) an "envelope" modulating the amplitude of the fast oscillating carrier wave. If the assumption is not valid, then this interpretation is not correct.&lt;/p&gt;
&lt;h3&gt;Narrowband Polychromatic Waves&lt;/h3&gt;
&lt;p&gt;In summary, narrowband polychromatic waves with a center frequency \( f_0 \) are modeled as the product of a fast rotating phasor and slowly varying envelope:&lt;/p&gt;
&lt;p&gt;$$ u \left( \mathbf{r}, t \right) = \Re \left[ U \left( \mathbf{r}, t \right) e^{-j 2 \pi f_0 t} \right] $$&lt;/p&gt;
&lt;p&gt;The amplitude and the phase of the envelope are the amplitude and phase of the real optical wave.&lt;/p&gt;
&lt;h2&gt;Coherence&lt;/h2&gt;
&lt;p&gt;While the expression for the analytic signal \( U \left( \mathbf{r}, t \right) \) as an integral over frequency components appears deterministic, the phase relationships between the spectral components are often unknown and vary randomly in time. As a result, the envelope of the optical wave will vary unpredictably and must be analyzed in terms of its statistical properties.&lt;/p&gt;
&lt;h3&gt;Monochromatic Light is Coherent&lt;/h3&gt;
&lt;p&gt;Since monochromatic light has only one spectral component by definition, it is completely coherent.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I mean monochromatic in the ideal sense, not like how we sometimes describe lasers.&lt;/li&gt;
&lt;li&gt;Monochromatic waves, like plane waves, cannot exist in real life. The uncertainy principle requires that a monochromatic wave exist for an infinite duration.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Goodman, Joseph W. Introduction to Fourier optics. Roberts and Company publishers (2005). ISBN 978-0974707723. &lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/a-very-brief-summary-of-the-analytic-signal-in-fourier-optics/#fnref:1" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;&lt;a href="https://physics.stackexchange.com/questions/451239/slowly-varying-envelope-approximation-what-does-it-imply"&gt;https://physics.stackexchange.com/questions/451239/slowly-varying-envelope-approximation-what-does-it-imply&lt;/a&gt; &lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/a-very-brief-summary-of-the-analytic-signal-in-fourier-optics/#fnref:2" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><category>analytic signal</category><category>coherence</category><category>fourier optics</category><guid>https://kylemdouglass.com/posts/a-very-brief-summary-of-the-analytic-signal-in-fourier-optics/</guid><pubDate>Tue, 01 Apr 2025 13:53:21 GMT</pubDate></item><item><title>A Very Brief Summary of Fresnel and Fraunhofer Diffraction Integrals</title><link>https://kylemdouglass.com/posts/a-very-brief-summary-of-fresnel-and-fraunhofer-diffraction-integrals/</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;p&gt;Fourier Optics is complicated, and though I have internalized its concepts over the years, I often still need to review the specifics of its mathematical models. Unfortunately, my go-to resource for this, Goodman's Fourier Optics&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="https://kylemdouglass.com/posts/a-very-brief-summary-of-fresnel-and-fraunhofer-diffraction-integrals/#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;, tends to disperse information across chapters and homework problems. This makes quick review difficult.&lt;/p&gt;
&lt;p&gt;Here I condense what I think are the essentials of Fresnel and Fraunhofer diffraction into one blog post.&lt;/p&gt;
&lt;h2&gt;Starting Point: the Huygens-Fresnel Principle&lt;/h2&gt;
&lt;p&gt;Ignore Chapter 3 of Goodman; it's largely irrelevant for practical work. The Huygens-Fresnel principle itself is a good intuitive model to start with.&lt;/p&gt;
&lt;h3&gt;The Model&lt;/h3&gt;
&lt;p&gt;An opaque screen with a clear aperture \( \Sigma \)  is located in the \( z = 0 \) plane with transverse coordinates \( \left( \xi , \eta \right ) \). It is illuminated by a complex-valued scalar field \( U \left( \xi, \eta \right) \). Let \( \vec{r_0} = \left( \xi, \eta, 0 \right) \) be a point in the plane of the aperture and \( \vec{r_1} = \left( x, y, z \right) \) be a point in the observation plane. The Huygens-Fresnel Principle provides the following formula for the diffracted field \( U \left( x, y \right) \) in the plane \( z \):&lt;/p&gt;
&lt;p&gt;$$ U \left( x, y; z \right) = \frac{z}{j \lambda} \iint_{\Sigma} U \left( \xi , \eta \right) \frac{\exp \left( j k r_{01} \right)}{r_{01}^2} \, d\xi d\eta $$&lt;/p&gt;
&lt;p&gt;with the distance \( r_{01}^2 = \left( x - \xi \right)^2 + \left( y - \eta \right)^2 + z^2 \).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We assumed an obliquity factor \( cos \, \theta = z / r_{01}\). The choice of obliquity factor depends on the boundary conditions discussed in Chapter 3, but again this isn't terribly important for practical work.&lt;/li&gt;
&lt;li&gt;The integral is a sum over secondary spherical wavelets emitted by each point in the aperture and weighted by the incident field and the obliquity factor.&lt;/li&gt;
&lt;li&gt;The factor \( 1 / j \) means that each secondary wavelet from a point \( \left( \xi, \eta \right) \) is 90 degrees out-of-phase with the incident field at that point.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Approximations used in the Huygens-Fresnel Principle&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;The electromagnetic field can be approximated as a complex-valued scalar field.&lt;/li&gt;
&lt;li&gt;\( r_{01} \gg \lambda \), or the observation screen is many multiples of the wavelength away from the aperture.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;The Fresnel Diffraction Integral&lt;/h2&gt;
&lt;h3&gt;The Fresnel Approximation&lt;/h3&gt;
&lt;p&gt;Rewrite \( r_{01} \) as:&lt;/p&gt;
&lt;p&gt;$$ r_{01} = z \sqrt{ 1 + \frac{\left( x - \xi \right)^2 + \left( y - \eta \right)^2}{z^2} } $$&lt;/p&gt;
&lt;p&gt;Apply the binomial approximation:&lt;/p&gt;
&lt;p&gt;$$ r_{01} \approx z + \frac{\left( x - \xi \right)^2 + \left( y - \eta \right)^2}{2z} $$&lt;/p&gt;
&lt;p&gt;In the Huygens-Fresnel diffraction integral, replace:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;\(r_{01}^2 \) in the denominator with \( z^2 \)&lt;/li&gt;
&lt;li&gt;\(r_{01}\) in the argument of the exponential with \( z + \frac{\left( x - \xi \right)^2 + \left( y - \eta \right)^2}{2z} \)&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;The Diffraction Integral: Form 1&lt;/h4&gt;
&lt;p&gt;Perform the substitutions for \( r_{01} \) into the Huygens-Fresnel formula that were mentioned above to get the first form of the Fresnel diffraction integral:&lt;/p&gt;
&lt;p&gt;$$ U \left( x, y; z \right) = \frac{ e^{jkz} }{j \lambda z} \iint_{-\infty}^{\infty} U \left( \xi , \eta \right) \exp \left\{ \frac{jk}{2z} \left[ \left( x - \xi \right)^2 + \left( y - \eta \right)^2 \right] \right\}  \,d\xi \,d\eta $$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It is space invariant, i.e. it depends only on the differences in coordinates \( \left( x - \xi \right) \) and \( \left( y - \eta \right) \).&lt;/li&gt;
&lt;li&gt;It represents a convolution of the input field with the kernel \( h \left( x, y \right) = \frac{e^{j k z}}{j \lambda z} \exp \left[ \frac{j k}{2 z} \left( x^2 + y^2 \right) \right] \).&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;The Diffraction Integral: Form 2&lt;/h4&gt;
&lt;p&gt;Expand the squared quantities inside the parantheses of Form 1 to get the second from of the integral:&lt;/p&gt;
&lt;p&gt;$$ U \left( x, y; z \right) = \frac{ e^{jkz} }{j \lambda z} e^{\frac{j k}{2 z} \left( x^2 + y^2 \right)} \iint_{-\infty}^{\infty} \left[ U \left( \xi , \eta \right) e^{\frac{j k}{2 z} \left( \xi^2 + \eta^2 \right)} \right] e^{-j \frac{2 \pi }{\lambda z} \left( x \xi + y \eta \right) }  \,d\xi \,d\eta $$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It is proportional to the Fourier transform of the product of the incident field and a parabolic phase curvature \( e^{\frac{j k}{2 z} \left( \xi^2 + \eta^2 \right)} \).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Phasor Conventions&lt;/h2&gt;
&lt;p&gt;Section 4.2.1 of Goodman is an interesting practical aside about how to identify whether a spherical or parabolic wavefront is converging or diverging based on the sign of its phasor. It is useful for solving the important homework problem 4.16 which concerns the diffraction pattern from an aperture that is illuminated by a converging spherical wave.&lt;/p&gt;
&lt;p&gt;Unfortunately, Figure 4.2 does not align well with its description in the text about negative z-values, and it's not clear how the interpretations change for point sources not at \( z = 0 \). I address this below.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Let the point of convergence (or center of divergence) of a spherical wave sit on the z-axis at \( z = Z \).&lt;/li&gt;
&lt;li&gt;The phasor describing the time-dependent part of the field in Goodman's notation is \( e^{-j 2 \pi f t} \).&lt;/li&gt;
&lt;li&gt;If we move away from the center of the wave such that \( z - Z \) is positive and we encounter wavefronts emitted earlier in time, then \( t \) is decreasing and the argument to the phasor is increasing. The wave is therefore diverging if the argument is positive.&lt;/li&gt;
&lt;li&gt;If we move away from the center of the wave  such that \( z - Z \) is negative and we encounter wavefronts emitted earlier in time, then \( t \) is decreasing and the argument to the phasor is increasing. However, a negative \( z - Z \) makes the phasor negative again so that it is in fact decreasing. The wave is therefore diverging if the argument is negative.&lt;/li&gt;
&lt;li&gt;Likewise for converging waves.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To summarize:&lt;/p&gt;
&lt;table border="1"&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Phasor&lt;/th&gt;
      &lt;th&gt; \( \left( z - Z \right) \) positive &lt;/th&gt;
      &lt;th&gt; \( \left( z - Z \right) \) negative &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;\( e^{ j k r} \)&lt;/td&gt;
      &lt;td&gt;diverging&lt;/td&gt;
      &lt;td&gt;converging&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\( e^{ -j k r} \)&lt;/td&gt;
      &lt;td&gt;converging&lt;/td&gt;
      &lt;td&gt;diverging&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2&gt;The Fraunhofer Diffraction Integral&lt;/h2&gt;
&lt;h3&gt;The Fraunhofer Approximation&lt;/h3&gt;
&lt;p&gt;Assume we are so far from the screen that the quadratic phasor inside the diffraction integral is effectively flat. This means: &lt;/p&gt;
&lt;p&gt;$$ z \gg \frac{k \left( \xi^2 + \eta^2 \right)_{\text{max}}}{2} $$&lt;/p&gt;
&lt;h3&gt;The Diffraction Integral&lt;/h3&gt;
&lt;p&gt;Applying the approximation above allows us to drop the quadratic phasor inside the Fresnel diffraction integral because it is effectively 1:&lt;/p&gt;
&lt;p&gt;$$ U \left( x, y; z \right) = \frac{ e^{jkz} }{j \lambda z} e^{\frac{j k}{2 z} \left( x^2 + y^2 \right)} \iint_{-\infty}^{\infty} U \left( \xi , \eta \right) e^{-j \frac{2 \pi }{\lambda z} \left( x \xi + y \eta \right) }  \,d\xi \,d\eta $$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Apart from the phase term that depends on \( z \), this expression represents a Fourier transform of the incident field.&lt;/li&gt;
&lt;li&gt;It appears to break spatial invariance because we no longer depend on differences of coordinates, e.g. \( x - \xi \). However, we can still use the Fresnel transfer function (the Fourier transform of the Fresnel convolution kernel) as the transfer function for Fraunhofer diffraction because if the Fraunhofer approximation is valid, then so is the Fresnel approximation.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Solution to Homework Problem 4.16&lt;/h2&gt;
&lt;p&gt;Problem 4.16 is important because it is a basis for the development of the frequency analysis of image-forming systems in later chapters of Goodman.&lt;/p&gt;
&lt;p&gt;The purpose of 4.16 is to show that the diffraction pattern of an aperture that is illuminated by a spherical converging wave in the Fresnel regime is the Fraunhofer diffraction pattern of the aperture.&lt;/p&gt;
&lt;h3&gt;Part a: Quadratic phase approximation to the incident wave&lt;/h3&gt;
&lt;p&gt;Let \( z = 0 \) be the plane of the aperture and \( z = Z \) be the observation plane. Additionally, let \( \left( \xi, \eta \right) \) represent the coordinates in the plane of the aperture, and \( \left( x, y \right) \) the coordinates in the observation plane. The spherical wave that illuminates the aperture is convering to a point \( \vec{r}_P = Y \hat{ \jmath} + Z \hat{k} \) in the observation plane.&lt;/p&gt;
&lt;p&gt;To find a quadratic phase approximation for the incident wave, start with its representation as a time-harmonic spherical wave of amplitude \( A \):&lt;/p&gt;
&lt;p&gt;$$ U \left( x, y, z \right) = A \frac{e^{j k |\vec{r} - \vec{r}_P|}}{|\vec{r} - \vec{r}_P|} $$&lt;/p&gt;
&lt;p&gt;Note that \( \vec{r} - \vec{r}_P = x \hat{\imath} + \left( y - Y \right) \hat{\jmath} + \left( z - Z \right) \hat{k} \). Its magnitude is&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
| \vec{r} - \vec{r}_P | &amp;amp;=&amp;amp; \sqrt{x^2 + \left( y - Y \right)^2 + \left( z - Z \right)^2} \\
&amp;amp;=&amp;amp; \left( z - Z \right) \sqrt{1 + \frac{x^2 + \left( y - Y \right)^2}{\left( z - Z \right)^2} } \\
&amp;amp;\approx&amp;amp; \left( z - Z \right) + \frac{ x^2 + \left( y - Y \right)^2 }{2 \left( z - Z \right)}
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;At first glance, there's a problem here because allowing \( \left( z - Z \right) \) to be negative will result in a negative value for the magnitude of the vector \( \left( \hat{r} - \hat{r}_P \right) \). However, if we use the above table for selecting \( e^{j k r} \) as the phasor for a converging wave when \( \left( z - Z \right) \) is negative, then we will have the correct sign of the argument to the phasor. We do however need to take the absolute value of the \( z - Z \) term in the denominator of the expression of the spherical wave.&lt;/p&gt;
&lt;p&gt;Replacing the distance in the phasor's argument with the two lowest order terms in the binomial expansion and the lowest order term in the denominator:&lt;/p&gt;
&lt;p&gt;$$ U \left( x, y, z \right) \approx A \frac{e^{j k \left(z - Z \right)} e^{j k \left[ x^2 + \left( y - Y \right)^2 \right] / 2 \left(z - Z \right) }}{\left|z - Z \right|} $$&lt;/p&gt;
&lt;p&gt;In the \( z = 0 \) plane, this becomes:&lt;/p&gt;
&lt;p&gt;$$ U \left( x, y; z = 0 \right) \approx A \left(x, y \right) \frac{e^{-j k Z} e^{-j k \left[ x^2 + \left( y - Y \right)^2 \right] / 2 Z }}{Z} $$&lt;/p&gt;
&lt;p&gt;I moved the finite extent of the aperture into a new function for the amplitude \( A \) above. This function is zero outside the aperture and a constant \( A \) inside it.&lt;/p&gt;
&lt;h3&gt;Part b: Diffraction pattern at the point \( P \)&lt;/h3&gt;
&lt;p&gt;Use the second form of the Fresnel diffraction integral to compute the diffraction pattern at \( P \):&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
U \left( x = 0, y = Y, z = Z \right) &amp;amp;=&amp;amp; \frac{ e^{jkZ} }{j \lambda Z} e^{\frac{j k Y^2}{2 Z}} \iint_{-\infty}^{\infty} \left[ U \left( \xi , \eta ; z = 0 \right) e^{\frac{j k}{2 Z} \left( \xi^2 + \eta^2 \right)} \right] e^{-j \frac{2 \pi }{\lambda Z} y \eta }  \,d\xi \,d\eta \\
&amp;amp;\approx&amp;amp; \frac{ e^{jkZ} e^{-jkZ} }{j \lambda Z^2} e^{\frac{j k Y^2}{2 Z}} \iint_{-\infty}^{\infty} A \left(\xi, \eta \right) \left[ e^{-\frac{j k}{2Z} \left[ \xi^2 + \left( \eta - Y \right)^2 \right]} e^{\frac{j k}{2 Z} \left( \xi^2 + \eta^2 \right)} \right] e^{-j \frac{2 \pi }{\lambda Z} y \eta }  \,d\xi \,d\eta \\
&amp;amp;\approx&amp;amp; \frac{1}{j \lambda Z^2} e^{\frac{j k Y^2}{2 Z} } \iint_{-\infty}^{\infty} A \left(\xi, \eta \right) \left[ e^{-\frac{j k}{2Z} \left( \xi^2 + \eta^2 - 2 \eta Y + Y^2 \right)} e^{\frac{j k}{2 Z} \left( \xi^2 + \eta^2 \right)} \right] e^{-j \frac{2 \pi }{\lambda Z} y \eta }  \,d\xi \,d\eta \\
&amp;amp;\approx&amp;amp; \frac{1}{j \lambda Z^2} \iint_{-\infty}^{\infty} A \left(\xi, \eta \right) e^{\frac{j k \eta Y}{Z}} e^{-j \frac{2 \pi}{\lambda Z} y \eta }  \,d\xi \,d\eta \\
&amp;amp;\approx&amp;amp; \frac{1}{j \lambda Z^2} \iint_{-\infty}^{\infty} A \left(\xi, \eta \right) e^{-j \frac{2 \pi }{\lambda Z} \left(\eta - Y \right) }  \,d\xi \,d\eta
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;The final expression above is proportional to the Fraunhofer diffraction pattern of the aperture. The reason that the Fraunhofer diffraction pattern appears as the result is that the converging spherical wavefronts exactly cancel the diverging quadratic phase term inside the Fresnel diffraction formula, leaving a simple Fourier transform of the aperture as a result.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Goodman, Joseph W. Introduction to Fourier optics. Roberts and Company publishers (2005). ISBN 978-0974707723. &lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/a-very-brief-summary-of-fresnel-and-fraunhofer-diffraction-integrals/#fnref:1" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><category>diffraction</category><category>Fraunhofer</category><category>Fresnel</category><guid>https://kylemdouglass.com/posts/a-very-brief-summary-of-fresnel-and-fraunhofer-diffraction-integrals/</guid><pubDate>Fri, 28 Mar 2025 08:06:03 GMT</pubDate></item><item><title>Data Type Alignment for Ray Tracing in Rust</title><link>https://kylemdouglass.com/posts/data-type-alignment-for-ray-tracing-in-rust/</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;p&gt;I would like to clean up my 3D ray trace routines for my &lt;a href="https://www.github.com/kmdouglass/cherry"&gt;Rust-based optical design library&lt;/a&gt;. The proof of concept (PoC) is finished and I now I need to make the code easier to modify to better support the features that I want to add on the frontend. I suspect that I might be able to make some performance gains as well during refactoring. Towards this end, I want to take a look at my ray data type from the perspective of making it CPU cache friendly.&lt;/p&gt;
&lt;p&gt;One of the current obstacles to adding more features to the GUI (for example color selection for different ray bundles) is how I handle individual rays. For the PoC it was fastest to add two additional fields to each ray to track where they come from and whether they are terminated:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Vec3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;f64&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Ray&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Vec3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;dir&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Vec3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;terminated&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;field_id&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;usize&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;A ray is just two, 3-element arrays of floats that specify the coordinates of a point on the ray and its direction cosines. I have additionally included a boolean flag to indicate whether the ray has terminated, i.e. gone out-of-bounds of the system or failed to converge during calculation of the intersection point with a surface.&lt;/p&gt;
&lt;p&gt;A ray fan is a collection of rays and is specified by a 3-tuple of wavelength, axis, and field; &lt;code&gt;field_id&lt;/code&gt; really should not belong to an individual Ray because it can be stored along with the set of all rays for the current ray fan. I probably added it because it was the easiest thing to do at the time to get the application working.&lt;/p&gt;
&lt;h2&gt;A deeper look into the Ray struct&lt;/h2&gt;
&lt;h3&gt;Size of a ray&lt;/h3&gt;
&lt;p&gt;Let's first look to see how much space the Ray struct occupies.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="cp"&gt;#[derive(Debug)]&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Vec3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;f64&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cp"&gt;#[derive(Debug)]&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Ray&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Vec3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;dir&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Vec3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;terminated&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;field_id&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;usize&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="fm"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Size of ray: {:?}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;size_of&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Ray&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;Ray&lt;/code&gt; struct occupies 64 bytes in memory. Does this make sense?&lt;/p&gt;
&lt;p&gt;The sizes of the individual fields are:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Field&lt;/th&gt;
&lt;th&gt;Size, bytes&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;pos&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dir&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;terminated&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;field_id&lt;/td&gt;
&lt;td&gt;8*&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;pos&lt;/code&gt; and &lt;code&gt;dir&lt;/code&gt; are each 24 bytes because they are each composed of three 64-bit floats and 8 bits = 1 byte. &lt;code&gt;terminated&lt;/code&gt; is only one byte because it is a boolean. &lt;code&gt;field_id&lt;/code&gt; is a &lt;a href="https://doc.rust-lang.org/std/primitive.usize.html"&gt;usize&lt;/a&gt;, which means that it depends on the compilation target. On 64-bit targets, such as x86_64, it is 64 bits = 8 bytes in size.&lt;/p&gt;
&lt;p&gt;Adding the sizes in the above table gives 57 bytes, not 64 bytes as was output from the example code. Why is this?&lt;/p&gt;
&lt;h3&gt;Alignment and padding&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Data_structure_alignment"&gt;Alignment&lt;/a&gt; refers to the layout of a data type in memory and how it is accessed. CPUs read memory in chunks that are equal in size to the &lt;a href="https://en.wikipedia.org/wiki/Word_(computer_architecture)"&gt;word size&lt;/a&gt;. Misaligned data is inefficient to access because the CPU requires more cycles than is necessary to fetch the data.&lt;/p&gt;
&lt;p&gt;Natural alignment refers to the most efficient alignment of a data type for CPU access. To achieve natural alignment, a compiler can introduce padding between fields of a struct so that the memory address of a field or datatype is a multiple of the field's/data type's alignment.&lt;/p&gt;
&lt;p&gt;As an example of misalignment, consider a 4-byte integer and that starts at memory address 5. The CPU has 32-bit memory words. To read the data, the CPU must:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;read bytes 4-7,&lt;/li&gt;
&lt;li&gt;read bytes 8-11,&lt;/li&gt;
&lt;li&gt;and combine the relevant parts of both reads to get the 4 bytes, i.e. bytes 5 - 8.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Notice that we must specify the memory word size to determine whether a data type is misaligned.&lt;/p&gt;
&lt;p&gt;Here is an important question: &lt;strong&gt;why can't the CPU just start reading from memory address 5?&lt;/strong&gt; The answer, as far as I can tell, is that it just can't. This is not how the CPU, RAM, and memory bus are wired.&lt;/p&gt;
&lt;h3&gt;Alignment in Rust&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://doc.rust-lang.org/reference/type-layout.html#size-and-alignment"&gt;Alignment in Rust&lt;/a&gt; is defined as follows:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The alignment of a value specifies what addresses are valid to store the value at. A value of alignment n must only be stored at an address that is a multiple of n.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="https://doc.rust-lang.org/reference/type-layout.html#the-rust-representation"&gt;The Rust compiler only guarantees the following&lt;/a&gt; when it comes to padding fields in structs:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;The fields are properly aligned.&lt;/li&gt;
&lt;li&gt;The fields do not overlap.&lt;/li&gt;
&lt;li&gt;The alignment of the type is at least the maximum alignment of its fields.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;So for my &lt;code&gt;Ray&lt;/code&gt; data type, its alignment is 8 because the maximum alignment of its fields is 8 bytes. (&lt;code&gt;pos&lt;/code&gt; and &lt;code&gt;dir&lt;/code&gt; are composed of 8-byte floating point numbers). The addresses of its fields are:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ray&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Ray&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Vec3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;dir&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Vec3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;terminated&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;false&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;field_id&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;unsafe&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="fm"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Address of ray.pos: {:p}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;addr_of&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ray&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="fm"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Address of ray.dir: {:p}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;addr_of&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ray&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dir&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="fm"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Address of ray.terminated: {:p}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;addr_of&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ray&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;terminated&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="fm"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Address of ray.field_id: {:p}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;addr_of&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ray&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;field_id&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I got the following results, which will vary from system-to-system and probably run-to-run:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="go"&gt;Address of ray.pos: 0x7fff076c6b50&lt;/span&gt;
&lt;span class="go"&gt;Address of ray.dir: 0x7fff076c6b68&lt;/span&gt;
&lt;span class="go"&gt;Address of ray.terminated: 0x7fff076c6b88&lt;/span&gt;
&lt;span class="go"&gt;Address of ray.field_id: 0x7fff076c6b80&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So the &lt;code&gt;pos&lt;/code&gt; field comes first at address &lt;code&gt;0x6b50&lt;/code&gt; (omitting the most significant hexadecimal digits). Then, 24 bytes later, comes &lt;code&gt;dir&lt;/code&gt; at address &lt;code&gt;0x6b68&lt;/code&gt;. Note that the difference is hexadecimal 0x18, which is decimal 16 + 8 = 24! So &lt;code&gt;pos&lt;/code&gt; really occupies 24 bytes like we previously calculated.&lt;/p&gt;
&lt;p&gt;Next comes &lt;code&gt;field_id&lt;/code&gt; and not &lt;code&gt;terminated&lt;/code&gt;. It is &lt;code&gt;0x6b80 - 0x6b68 = 0x0018&lt;/code&gt;, or 24 bytes after &lt;code&gt;dir&lt;/code&gt; like before. So far we have no padding, but the compiler did swap the order of the fields. Finally, &lt;code&gt;terminated&lt;/code&gt; is 8 bytes after &lt;code&gt;field_id&lt;/code&gt; because &lt;code&gt;field_id&lt;/code&gt; is 8-byte aligned. This means that the Rust compiler must have placed 7 bytes of padding after the &lt;code&gt;terminated&lt;/code&gt; field.&lt;/p&gt;
&lt;h2&gt;What makes a good data type?&lt;/h2&gt;
&lt;p&gt;As I mentioned, I already know that &lt;code&gt;field_id&lt;/code&gt; shouldn't belong to the ray for reasons related to data access by the programmer. So the reason for removing it from the &lt;code&gt;Ray&lt;/code&gt; struct is not related to performance. But what about the &lt;code&gt;terminated&lt;/code&gt; bool? Well, in this case, it's resulting in 7 extra bytes of padding for each ray!&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="cp"&gt;#[derive(Debug)]&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Vec3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;f64&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cp"&gt;#[derive(Debug)]&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Ray&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Vec3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;dir&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Vec3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;terminated&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ray&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Ray&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Vec3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;dir&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Vec3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;terminated&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;false&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="fm"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Size of ray: {:?}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;size_of&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Ray&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This program prints &lt;code&gt;Size of ray : 56&lt;/code&gt;, but 24 + 24 + 1 = 49. In both versions we waste 7 bytes.&lt;/p&gt;
&lt;h3&gt;Fitting a Ray into the CPU cache&lt;/h3&gt;
&lt;p&gt;Do I have a good reason to remove &lt;code&gt;terminated&lt;/code&gt; from the &lt;code&gt;Ray&lt;/code&gt; struct because it wastes space? Consider the following:&lt;/p&gt;
&lt;p&gt;We want as many &lt;code&gt;Ray&lt;/code&gt; instances as possible to fit within a CPU cache line if we want to maximize performance. (Note that I'm not saying that we necessarily want to maximize performance because that comes with tradeoffs.) Each CPU core on my AMD Ryzen 7 has a 64 kB L1 cache with 64 byte cache lines. This means that I can fit only 1 of the current version of &lt;code&gt;Ray&lt;/code&gt; into each cache line for a total of 64 kB / 64 bytes = 1024 rays maximum in the L1 cache of each core. If I remove &lt;code&gt;field_size&lt;/code&gt; and &lt;code&gt;terminated&lt;/code&gt;, then the size of a ray becomes 48 bytes. Unfortunately, this means that only one &lt;code&gt;Ray&lt;/code&gt; instance fits in a cache line, just as before with a 64 byte &lt;code&gt;Ray&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But, if I also reduce my precision to 32-bit floats, then the size of a &lt;code&gt;Ray&lt;/code&gt; becomes 6 * 4 = 24 bytes and I have doubled the number of rays that fit in L1 cache.&lt;/p&gt;
&lt;p&gt;Now what if I reduced the precision but kept &lt;code&gt;terminated&lt;/code&gt;? Then I get 6 * 4 + 8 = 32 bytes per Ray and I still have 2 rays per cache line.&lt;/p&gt;
&lt;p&gt;I conclude that there is no reason to remove &lt;code&gt;terminated&lt;/code&gt; for performance reasons. Reducing my floating point precision would produce a more noticeable effect on the cache locality of the &lt;code&gt;Ray&lt;/code&gt; data type.&lt;/p&gt;
&lt;h2&gt;Does all of this matter?&lt;/h2&gt;
&lt;p&gt;My Ryzen 7 laptop can trace about 600 rays through 3 surfaces in 380 microseconds with Firefox, Slack, and Outlook running. At this point, I doubt that crafting my data types for cache friendliness is going to offer a significant payoff. Creating data types that are easy to work with is likely more important.&lt;/p&gt;
&lt;p&gt;I do think, however, that it's important to understand these concepts. If I do need to tune the performance in the future, then I know where to look.&lt;/p&gt;</description><category>ray tracing</category><category>rust</category><guid>https://kylemdouglass.com/posts/data-type-alignment-for-ray-tracing-in-rust/</guid><pubDate>Mon, 24 Feb 2025 07:40:00 GMT</pubDate></item><item><title>An Analog LED Dimmer Circuit</title><link>https://kylemdouglass.com/posts/an-analog-led-dimmer-circuit/</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;p&gt;I recently needed to build a circuit to control the brightness of a 4 W LED with a knob. I know basic electronics, and I thought this would be easy. I spoke to a few people whom I know and are knowledgable in electronics. I also asked people on Reddit. A lot of people said it would be easy.&lt;/p&gt;
&lt;p&gt;As it turns it, it wasn't easy.&lt;/p&gt;
&lt;h2&gt;The Requirements&lt;/h2&gt;
&lt;p&gt;My requirments are simple:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The brightness should be manually adjustable with a knob from OFF to nearly full ON.&lt;/li&gt;
&lt;li&gt;The LED will serve as the light source of a microscope trans-illuminator. It should work across a large range of frame acquisition rates (1 Hz to 1 kHz, or exposure times of 1 ms to 1 s).&lt;/li&gt;
&lt;li&gt;The range of brightnesses should be variable across the dynamic range of the camera, which in my case is 35,000:1, or about 90 dB.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I don't care about efficiency. I don't care about whether I can use a Raspberry Pi to control it. I don't care whether it can be turned on or off with different logic levels. I just want a knob that I can turn to make the LED brighter or dimmer.&lt;/p&gt;
&lt;p&gt;In spite of the insistence of several people that I communicated with on the internet, I decided that the second requirement would preclude using pulse width modulation (PWM) to dim the LED. Even when I could convince others that PWM almost always causes aliasing at high frame rates, they tried to find obscure work arounds so I could still use PWM. I really do appreciate all the feedback I got. But I also learned that PWM is the hammer of the electronics world that makes everything look like a nail&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="https://kylemdouglass.com/posts/an-analog-led-dimmer-circuit/#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;h2&gt;The Circuit&lt;/h2&gt;
&lt;p&gt;I reached out to a friend of mine who's a wizard at analog electronics&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="https://kylemdouglass.com/posts/an-analog-led-dimmer-circuit/#fn:2"&gt;2&lt;/a&gt;&lt;/sup&gt;. He suggested to use a MOSFET and to vary the gate-source voltage to control the current through the LED.&lt;/p&gt;
&lt;p&gt;After a lot of thinking and reading, I arrived at &lt;a href="https://tinyurl.com/2cnw45fy"&gt;the following circuit&lt;/a&gt;:&lt;/p&gt;
&lt;figure&gt;
  &lt;img src="https://kylemdouglass.com/images/led-dimmer-circuit-v0.png"&gt;
&lt;/figure&gt;

&lt;p&gt;The LED is an Osram Oslon star LED (LST1-01F05-4070-01) with a maximum current of 1.3 A and a maximum forward voltage of 3.2 V. The MOSFET is an IRF510, whose gate-source threshold voltage is about 3 V.&lt;/p&gt;
&lt;p&gt;Here's a brief explanation of what each component does:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Voltage source&lt;/strong&gt; : This is just a 12 V wall wart.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;200 nF capacitor&lt;/strong&gt; : This smooths out any fluctuations from the wall wart.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;50 kOhm potentiometer&lt;/strong&gt; : The "knob." Turning it will vary the gate-source voltage of the MOSFET, which controls how much current flows through the LED.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;50 kOhm resistor&lt;/strong&gt; : This along with the potentiometer forms a voltage divider to keep the minimum voltage at the MOSFET gate close to where the LED turns on. Without it, you need to rotate the potentiometer almost half of its full range for the LED to turn on.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;300 nF capacitor&lt;/strong&gt; : A debounce capacitor that smooths out the mechanical irregularities of the pot when it turns.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IRF510 MOSFET&lt;/strong&gt; : Basically a valve that I can vary continuously to control the LED current by setting the voltage at the gate.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LED&lt;/strong&gt; : So pretty.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;10 Ohm resistor&lt;/strong&gt; : This limits the current through the resistor. I calculated its value by dividing the maximum supply voltage minus the maximum forward voltage drop across the LED by the maximum current, then rounded up for safety.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$$ R = \frac{V}{I} = \frac{\left( 12 \, V - 3.2 \, V \right) }{1.3 \, A} = 6.8 \Omega $$&lt;/p&gt;
&lt;p&gt;The resistor also has to handle a large power dissipation at the maximum current:&lt;/p&gt;
&lt;p&gt;$$ P = I^2 R = \left(1.3 \, A \right)^2 \left( 10 \Omega \right) = 16.9 W $$&lt;/p&gt;
&lt;p&gt;I decided instead to keep the current to less than 1 Amp so that I could use a 10 Watt resistor that I had.&lt;/p&gt;
&lt;p&gt;Power dissipation is also why we don't just use a potentiometer to control the LED current: my pots were only rated up to about 50 mW, whereas I expected that the MOSFET would have handle loads on the order of Watts due to the high current.&lt;/p&gt;
&lt;h2&gt;What I Learned&lt;/h2&gt;
&lt;h3&gt;I really need to study MOSFETS&lt;/h3&gt;
&lt;p&gt;I still don't really know how to solve circuits with MOSFETs. I arrived at the above circuit largely by trial-and-error on a prototype and by performing naive calculations on the voltage divider that turned out to not be entirely correct. I also expected that the LED would turn on once I passed the MOSFET's gate-source voltage threshold, but this turned out to be off by about 2 or 3 V.&lt;/p&gt;
&lt;h3&gt;MOSFETs suffer from second order effects&lt;/h3&gt;
&lt;p&gt;There is currently a hysteresis in the gate-ground voltage at when the LED turns on and when it turns off by about half a Volt. According to a helpful person on Reddit, this is likely due to a change in both the LEDs forward voltage and the MOSFET's threshold voltage with temperature once the current starts flowing. A possible fix is to swap the order of the LED and the MOSFET so that only the MOSFET will contribute to the hysteresis.&lt;/p&gt;
&lt;h3&gt;You can always complicate things to make them better&lt;/h3&gt;
&lt;p&gt;The same person on Reddit above also suggested making the circuit robust to temperature variations by adding an opamp to control the MOSFET gate voltage. It would compensate for temperature changes by comparing the potentiometer value to the 10 Ohm resistor in a closed feedback loop.&lt;/p&gt;
&lt;h3&gt;Electronics is an art&lt;/h3&gt;
&lt;p&gt;Yes, electronics is a science, but I would argue that having to mentally juggle second order effects and the fact that experts seem to make an initial design "by feel" are signatures of an art.&lt;/p&gt;
&lt;p&gt;It also struck me how nearly every step of the process forced me to take a detour to address something I hadn't at first considered, such as current limits in the wires and large variations in the MOSFET specs.&lt;/p&gt;
&lt;p&gt;The next time I need to do something like this, I will expect the problem to take longer to solve than I first anticipate.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;To my non-native English speaking readers: I mean that people try to use PWM to solve problems where it's not appropriate. &lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/an-analog-led-dimmer-circuit/#fnref:1" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;And if you play electric guitar, be sure to check out his handmade effects pedals: &lt;a href="https://www.volumeandpower.com/"&gt;https://www.volumeandpower.com/&lt;/a&gt;. &lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/an-analog-led-dimmer-circuit/#fnref:2" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><category>electronics</category><category>optics</category><guid>https://kylemdouglass.com/posts/an-analog-led-dimmer-circuit/</guid><pubDate>Fri, 17 Jan 2025 08:08:27 GMT</pubDate></item><item><title>Meta-Biophysics of the Cell</title><link>https://kylemdouglass.com/posts/meta-biophysics-of-the-cell/</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;p&gt;I work in a biophysics lab applying microscopy techniques to study cell biology. I am not a biologist, and I was not trained as one. I therefore have had to develop heuristics to help me understand what cell biologists do and to communicate with them effectively.&lt;/p&gt;
&lt;p&gt;In this post, I present these heuristics as a sort of model for how I think that cell biologists think. I collectively call them "Meta-Biophysics of the Cell" because:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;they model the models of cell biologists, hence they are a meta-model,&lt;/li&gt;
&lt;li&gt;they are inspired by physics and quantitative modeling, and&lt;/li&gt;
&lt;li&gt;I limit myself to cellular processes and not, for example, in vitro or organismal studies.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Furthermore, they are heavily biased by my work in microscopy.&lt;/p&gt;
&lt;p&gt;These heuristics may very well be wrong. I do not pretend to understand biology nearly as well as a biologist. If you think I am wrong, please do not hesitate to leave a comment and explain why.&lt;/p&gt;
&lt;p&gt;They also are certainly not complete. I present here only what I think the most important heuristics are.&lt;/p&gt;
&lt;h2&gt;Biologists want to know distributions of proteins across space and time&lt;/h2&gt;
&lt;p&gt;Cell biology is concerned with understanding the structure and behavior of cells as complex phenomena that emerge from the interactions of molecules. The types of these molecules may be proteins, nucleic acids, lipids, or some other type. I will use the term "protein" generally because &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;it's easier than always listing all the types of molecules,&lt;/li&gt;
&lt;li&gt;it's more precise than just saying "molecule"&lt;/li&gt;
&lt;li&gt;there are at least 10,000 different types of proteins in the human cell, making proteins a core building block of the cell, and&lt;/li&gt;
&lt;li&gt;these heuristics do not change if you substitute another type of molecule for the word "protein."&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Within a single cell, we can model the number of proteins at a point in space and a point in time with a function \( N \left( \mathbf{r}, t \right) \). This is a spatiotemporal distribution for protein number density. Its dimensions are in numbers of proteins per unit of volume.&lt;/p&gt;
&lt;p&gt;A single protein can be represented as a point in space and time, such as a delta function:&lt;/p&gt;
&lt;p&gt;$$ N \left( \mathbf{r}, t \right) = \delta \left( \mathbf{r}, t \right) $$&lt;/p&gt;
&lt;p&gt;Of course a real protein occupies some volume and is not a point, but at the level of a cell I think that this is an adequate model for what cell biologists want to know about protein distributions.&lt;/p&gt;
&lt;p&gt;But wait. There are more than ten thousand types of proteins within the cell. Some proteins are of high abundance, and some are very rare. So it is not sufficient merely to count proteins in space and time: we also need to identify their types. For this, I assign a unique ID to each type that I call \( s \) for "species". Our model now becomes a function of another variable, one that is categorical rather than continuous:&lt;/p&gt;
&lt;p&gt;$$ N \left( \mathbf{r}, t ; s\right) $$&lt;/p&gt;
&lt;p&gt;Below I show a simplified schematic of the volume that this model occupies. It is simplified because I show only one spatial dimension (otherwise it would be a five dimensional hypervolume). I saw a figure like this once in a paper about a decade ago, but sadly I cannot find it to credit it. (&lt;em&gt;Update 2025-01-30: The paper referred to is &lt;a href="https://doi.org/10.1016/j.cell.2007.08.031"&gt;Megason and Fraser, "Imaging in Systems Biology," Cell 130(5), 784-795 (2007)&lt;/a&gt;&lt;/em&gt;)&lt;/p&gt;
&lt;figure&gt;
  &lt;img src="https://kylemdouglass.com/images/protein-distributions.png"&gt;
  &lt;figcaption&gt;A cell can be represented as a "volume" of spatiotemporal distributions where one spatiotemporal slice belongs to each protein species.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;The \( x \) and \( t \) dimensions are continuous; the \( s \) dimension is a discrete, categorical variable. Each \( s \) slice is the spatiotemporal distribution of that protein within a single cell. Each point in the volume is the protein density for that point in space and time and for that species of protein.&lt;/p&gt;
&lt;p&gt;Individual proteins might also vary amongst themselves as in, for example, post translation modifications. This is not really a problem for the above model because we can use a different value for the \( s \) of each variant.&lt;/p&gt;
&lt;h3&gt;Creation and degradation of a protein&lt;/h3&gt;
&lt;p&gt;The appearance and disappearance of a protein is modeled as a non-zero value over a time range from \( t_0 \) to \( t_1 \). For example, a single protein existing over a finite time interval may be expressed as&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
 &amp;amp;&amp;amp;\delta \left( \mathbf{r}, t \right), \, t_0 &amp;lt; t &amp;lt; t_1 \\
 &amp;amp;&amp;amp;0, \, \text{otherwise}
\end{eqnarray}$$&lt;/p&gt;
&lt;h3&gt;Biologists can only measure slices of protein distributions&lt;/h3&gt;
&lt;p&gt;Look again at the figure above. Remember that there are in fact five dimensions. Can any one experimental technique measure the whole hypevolume?&lt;/p&gt;
&lt;p&gt;No. Instead, biologists can measure slices from the volume and try to piece together a complete picture of \( N \) from individual measurements.&lt;/p&gt;
&lt;p&gt;For example, fluorescence microscopy can measure proteins in space and time. Sometimes it can measure in 3 spatial dimensions, but it is easier to measure in 2. Unfortunately, it can only measure a small of number of protein species relative to all the proteins that are in the cell. These would correspond to the different fluorescence channels of the measurement. Thus, fluorescence microscopy provides a slice of the volume that looks like the following:&lt;/p&gt;
&lt;figure&gt;
  &lt;img src="https://kylemdouglass.com/images/protein-distributions-microscopy-slice.png"&gt;
  &lt;figcaption&gt;Fluorescence microscopy measures a small slice of the spatiotemporal protein distribution that represents a cell.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Other types of measurements, such as those in single cell proteomics, might measure a large number of proteins but cannot resolve them in space and time. They would slice the volume like this:&lt;/p&gt;
&lt;figure&gt;
  &lt;img src="https://kylemdouglass.com/images/protein-distributions-proteomics-slice.png"&gt;
&lt;/figure&gt;

&lt;p&gt;So after their measurements, biologists are always going to be left with less than the total amount of information contained within a single cell because they can only measure slices of \( N \).&lt;/p&gt;
&lt;h2&gt;Organelles are mutually exclusive slices of protein distributions in space&lt;/h2&gt;
&lt;p&gt;Consider a mitochondrion. It is a membrane-bound organelle. Everything inside the mitochondrion is considered part of the organelle, and everything outside it is not. An organelle is therefore a mutually-exclusive slice through the volume dimensions of \( N \).&lt;/p&gt;
&lt;p&gt;The slices are mutually-exclusive because two mitochondria cannot occupy the same volume at the same time and have a distinct identity.&lt;/p&gt;
&lt;p&gt;For non-membrane bound organelles, keep reading.&lt;/p&gt;
&lt;h3&gt;Organelles contain many types proteins&lt;/h3&gt;
&lt;p&gt;If we use the definition of an organelle as a mutually-exclusive slice through the volume dimensions of \( N \), then we can look sideways along the \( s \) dimension to find all the proteins that belong to the organelle. If the distribution for protein \( s_i \) is non-zero inside an organelle's volume at a given time, then it belongs to the organelle. The set of all proteins within the volume slice at a given time constitute the organelle.&lt;/p&gt;
&lt;h3&gt;Knowing \( N \) doesn't by itself tell us what is and is not an organelle&lt;/h3&gt;
&lt;p&gt;Membrane-bound organelles are easy to identify because of their structure. Other sets of proteins within a given volume may or may not form an organelle. In these situations, we might look at their function instead to decide whether the volume is or is not occupied by an organelle.&lt;/p&gt;
&lt;p&gt;For example, organelles like the centrosome have a diffuse, pericentriolar material that surround them. In this case, the border defining what is and isn't inside the centrosome is likely to be somewhat arbitrary.&lt;/p&gt;
&lt;h2&gt;Cause and Effect is the probability of one protein distribution given another&lt;/h2&gt;
&lt;p&gt;At this time, I am much less certain about how function and causal relationships fit within this model. It is nevertheless important because biologists are deeply interested in the function of proteins and other complexes. To a rough approximation, I would say that cause and effect describes how the spatiotemporal distributions of a subset of protein species can serve as a predictor of another distribution at a later time. In other words, we can assign a probability to a certain distribution given another one.&lt;/p&gt;
&lt;p&gt;I would guess that not every possible set proteins is linked by causal relationships. This would mean that the limitations that come from being able to sample slices of the protein distribution hypervolume are not so significant. You would then want choose your measurements so that you slice the volume to include only the species that are causally linked for the phenomenon that you are studying.&lt;/p&gt;
&lt;p&gt;As a consequence of this, the causal links between distributions are likely more important than knowing \( N \). I doubt that we can have a satisfactory understanding of the cell if we could exhaustively measure \( N \) for even a single cell.&lt;/p&gt;
&lt;h3&gt;Interactions between proteins require spatial colocalization&lt;/h3&gt;
&lt;p&gt;Protein-protein interactions occur on length-scales on the order of the size of individual proteins. For two different proteins to "interact" we require that they be colocated less than this distance. Colcalization means that two proteins are located less than the distance required for an interaction to occur.&lt;/p&gt;
&lt;p&gt;Furthermore, colocalization is necessary but not sufficient for an interaction. A real interaction involves the chemistry between the two different species.&lt;/p&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;In summary, my main three heuristics for meta-biophysics of the cell are:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Biologists want to know distributions of proteins across space and time&lt;/li&gt;
&lt;li&gt;Organelles are mutually exclusive slices of protein distributions in space&lt;/li&gt;
&lt;li&gt;Cause and Effect is the probability of one or more protein distributions given another&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I find that nearly all the problems that the cell biologists that I work with can be reformulated into this language. I emphasize again that the "real" science is being done by the biologists, and I in no way mean to diminish the complexity of their work. These heuristics are merely a tool that I use to understand what they are doing when I myself am unfamiliar with their jargon and mental models.&lt;/p&gt;</description><category>biophysics</category><guid>https://kylemdouglass.com/posts/meta-biophysics-of-the-cell/</guid><pubDate>Tue, 14 Jan 2025 16:07:30 GMT</pubDate></item><item><title>Coordinate Systems for Modeling Microscope Objectives</title><link>https://kylemdouglass.com/posts/coordinate-systems-for-modeling-microscope-objectives/</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;p&gt;A common model for infinity corrected microscope objectives is that of an aplanatic and telecentric optical system. In many developments of this model, emphasis is placed upon the calculation of the electric field near the focus. However, this has the effect that the definition of the coordinate systems and geometry are conflated with the determination of the fields. In addition, making the model amenable to computation often occurs as an afterthought.&lt;/p&gt;
&lt;p&gt;In this post I will explore the geometry of an aplanatic system for modeling high NA objectives with an emphasis on computational implementations. My approach follows Novotny and Hecht&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="https://kylemdouglass.com/posts/coordinate-systems-for-modeling-microscope-objectives/#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt; and Herrera and Quinto-Su&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="https://kylemdouglass.com/posts/coordinate-systems-for-modeling-microscope-objectives/#fn:2"&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;h2&gt;The Model Components&lt;/h2&gt;
&lt;p&gt;The model system is illustrated below:&lt;/p&gt;
&lt;figure&gt;
  &lt;img src="https://kylemdouglass.com/images/aplanatic-telecentric-system.png"&gt;
  &lt;figcaption&gt;A high NA, infinity corrected microscope objective as an aplanatic and telecentric optical system.
&lt;/figcaption&gt;&lt;/figure&gt;

&lt;p&gt;In this model, we abstract over the details of the objective by representing it as four surfaces:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A back focal plane containing an aperture stop&lt;/li&gt;
&lt;li&gt;A back principal plane, \( P \)&lt;/li&gt;
&lt;li&gt;A front principal surface, \( P' \)&lt;/li&gt;
&lt;li&gt;A front focal plane&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The space to the left of the back principal plane is called the infinity space. The space to the right of the front principal surface is called the sample space.&lt;/p&gt;
&lt;p&gt;We let the infinity space refractive index \( n_1 = 1 \) because it is in air. The refractive index \( n_2 \) is the refractive index of the immersion medium.&lt;/p&gt;
&lt;p&gt;The unit vectors \( \mathbf{n} \) are not used in this discussion; they are relevant for computing the fields.&lt;/p&gt;
&lt;h3&gt;Assumptions&lt;/h3&gt;
&lt;p&gt;We make one assumption: the system obeys the sine condition. The meaning of this will be explained later.&lt;/p&gt;
&lt;p&gt;An aplanatic system is one that obeys the sine condition.&lt;/p&gt;
&lt;p&gt;We will not assume the intensity law to conserve energy because it is only necessary when computing the electric field near the focus.&lt;/p&gt;
&lt;h3&gt;The Aperture Stop and Back Focal Plane&lt;/h3&gt;
&lt;p&gt;The aperture stop (AS) of an optical system is the element that limits the angle of the marginal ray.&lt;/p&gt;
&lt;p&gt;The system is telecentric because the aperture stop is located in the back focal plane (BFP). We can shape the focal field by spatially modulating any of the amplitude, phase, or polarization of the incident light in a plane conjugate to the BFP.&lt;/p&gt;
&lt;h3&gt;The Back Principal Plane&lt;/h3&gt;
&lt;p&gt;This is the plane in infinity space at which rays appear to refract. It is a plane because rays coming from a point in the front focal plane all emerge into the infinity space in the same direction.&lt;/p&gt;
&lt;p&gt;Strictly speaking, focus field calculations require us to propagate the field from the AS to the back principal plane before computing the Debye diffraction integral, but this step is often omitted&lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="https://kylemdouglass.com/posts/coordinate-systems-for-modeling-microscope-objectives/#fn:3"&gt;3&lt;/a&gt;&lt;/sup&gt;. The assumptions of paraxial optics should hold here.&lt;/p&gt;
&lt;h3&gt;The Front Principal Surface&lt;/h3&gt;
&lt;p&gt;The front principal surface is the surface at which rays appear to refract in the sample space. It is a surface because&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;this is a non-paraxial system, and&lt;/li&gt;
&lt;li&gt;we assumed the sine condition.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The sine condition states that refraction of a ray coming from an on-axis point in the front focal plane occurs on a spherical cap centered upon the focal point. The distance from the optical axis of the point of intersection of the ray with the surface is proportional to the sine of the angle that the ray makes with the axis.&lt;/p&gt;
&lt;p&gt;The principal surface is in the far field of the electric field coming from the focal region. For this reason, we can represent a point on this surface as representing a single ray or a plane wave&lt;sup id="fnref2:1"&gt;&lt;a class="footnote-ref" href="https://kylemdouglass.com/posts/coordinate-systems-for-modeling-microscope-objectives/#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;h3&gt;The Front Focal Plane&lt;/h3&gt;
&lt;p&gt;This plane is located a distance \( n_2 f \) from the principal surface&lt;sup id="fnref:4"&gt;&lt;a class="footnote-ref" href="https://kylemdouglass.com/posts/coordinate-systems-for-modeling-microscope-objectives/#fn:4"&gt;4&lt;/a&gt;&lt;/sup&gt;. It is not at a distance \( f \) from this surface. This is a result of imaging in an immersion medium.&lt;/p&gt;
&lt;h2&gt;Geometry and Coordinate Systems&lt;/h2&gt;
&lt;h3&gt;The Aperture Stop Radius&lt;/h3&gt;
&lt;p&gt;The aperture stop radius \( R \) corresponds to the distance from the axis to the point where the marginal ray intersects the front prinicpal surface. In the sample space, the marginal ray travels at an angle \( \theta_{max} \) with respect to the axis.&lt;/p&gt;
&lt;p&gt;Under the sine condition, this height is&lt;/p&gt;
&lt;p&gt;$$ R = n_2 f \sin{ \theta_{max} } = f \, \text{NA} $$&lt;/p&gt;
&lt;p&gt;The right-most expression uses the definition of the numerical aperture \( \text{NA} \equiv n \sin{ \theta_{max} } \).&lt;/p&gt;
&lt;p&gt;Compare this result to the oft-cited expression for the entrance pupil diameter of an objective lens: \( D = 2 f \, \text{NA} \). They are the same. This makes sense because an entrance pupil is either&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;an image of an aperture stop, or&lt;/li&gt;
&lt;li&gt;a physical stop.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;The Back Principal Plane&lt;/h3&gt;
&lt;p&gt;There are two independent coordinate systems in the back principal plane:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;the spatial coordinate system defining the far field positions \( \left( x_{\infty} , y_{\infty} \right) \), and&lt;/li&gt;
&lt;li&gt;the coordinate system of the angular spectrum of plane waves \( \left( k_x, k_y \right) \).&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;The Far Field Coordinate System&lt;/h4&gt;
&lt;p&gt;The far field coordinate system may be written in Cartesian form as \( \left( x_{\infty} , y_{\infty} \right) \). It also has a cylindrical representation as&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
\rho &amp;amp;=&amp;amp; \sqrt{x_{\infty}^2 + y_{\infty}^2} \\
\phi &amp;amp;=&amp;amp; \arctan \left( \frac{y_{\infty}}{x_{\infty}} \right)
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;The cylindrical representation appears to be preferred in textbook developments of the model. The Cartesian representation is likely preferred for computational models because it works naturally with two-dimensional arrays of numbers, and because beam shaping elements such as spatial light modulators are rectangular arrays of pixels&lt;sup id="fnref2:2"&gt;&lt;a class="footnote-ref" href="https://kylemdouglass.com/posts/coordinate-systems-for-modeling-microscope-objectives/#fn:2"&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;h4&gt;The Angular Spectrum Coordinate System&lt;/h4&gt;
&lt;p&gt;Each point in the angular spectrum coordinate system represents a plane wave in the sample space that is traveling at an angle \( \theta \) to the axis according to:&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
k_x &amp;amp;=&amp;amp; k \sin \theta \cos \phi \\
k_y &amp;amp;=&amp;amp; k \sin \theta \sin \phi \\
k_z &amp;amp;=&amp;amp; k \cos \theta
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;where \( k = 2 \pi n_2 / \lambda = n_2 k_0 \).&lt;/p&gt;
&lt;p&gt;Along the y-axis ( \( x_{\infty} = 0 \) ), the maximum value of \( k_y \) is \(n_2 k_0 \sin \theta_{max} = k_0 \, \text{NA} \).&lt;/p&gt;
&lt;p&gt;Substitute in the expression \( \text{NA} = R / f \) and we get \(k_{y, max} = k_0 R / f\). But \( R = y_{\infty, max} \). This (and similar reasoning for the x-axis) implies that:&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
k_x &amp;amp;=&amp;amp; k_0 x_{\infty} / f \\
k_y &amp;amp;=&amp;amp; k_0 y_{\infty} / f
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;The above equations link the angular spectrum coordinate system to the far field coordinate system. They are no longer independent once \( f \) and \( \lambda \) are specified.&lt;/p&gt;
&lt;h2&gt;Numerical Meshes&lt;/h2&gt;
&lt;p&gt;There are four free parameters for defining the coordinate systems of the numerical meshes:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The numerical aperture, \( \text{NA} \)&lt;/li&gt;
&lt;li&gt;The wavelength, \( \lambda \)&lt;/li&gt;
&lt;li&gt;The focal length, \( f \)&lt;/li&gt;
&lt;li&gt;The linear mesh size, \( L \)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Below is a figure that illustrates the construction of the meshes. Both the far field and angular spectrum coordinate systems are represented by a \( L \times L \) array. \( L = 16 \) in the figure below. In general the value of \( L \) should be a power of 2 to help ensure the efficiency of the Fast Fourier Transform (FFT). By considering only powers of 2, we need only consider arrays of even size as well.&lt;/p&gt;
&lt;figure&gt;
  &lt;img src="https://kylemdouglass.com/images/pupil-function-simulation-mesh.png"&gt;
  &lt;figcaption&gt;A numeric mesh representing the far field and angular spectrum coordinate systems of a microscope objective. Fields are sampled at the center of each mesh pixel.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;The fields are defined on a region of circular support that is centered on this array. The radius of the domain of the far field coordinate system is \( f \text{NA} \); the radius of the domain of the angular spectrum coordinate system is \( k_0 \text{NA} \).&lt;/p&gt;
&lt;p&gt;The boxes that are bound by the gray lines indicate the location of each field sample. The \( \left( x_{\infty} , y_{\infty} \right) \) and the \( \left( k_x, k_y \right) \) coordinate systems are sampled at the center of each gray box. The origin is therefore not sampled, which will help avoid division by zero errors when the fields are eventually computed.&lt;/p&gt;
&lt;p&gt;The figure suggests that we could create only one mesh and scale it by either \( f \text{NA} \) or \( k_0 \text{NA} \) depending on which coordinate system we are working with. The normalized coordinates become \( \left( x_{\infty} / \left( f \text{NA} \right), y_{\infty} / \left( f \text{NA} \right) \right) \) and \( \left( k_x / \left( k_0 \text{NA} \right), k_y / \left( k_0 \text{NA} \right) \right) \).&lt;/p&gt;
&lt;h3&gt;1D Mesh Example&lt;/h3&gt;
&lt;p&gt;As an example, let \( L = 16 \). To four decimal places, the normalized coordinates are \( -1.0000, -0.8667, \ldots, -0.0667, 0.0667, \ldots, 0.8667, 1.0000 \).&lt;/p&gt;
&lt;p&gt;The spacing between array elements is \( 2 / \left( L - 1 \right) = 0.1333 \). Note that 0 is not included in the 1D mesh as it goes from -0.0667 to 0.0667.&lt;/p&gt;
&lt;p&gt;A 2D mesh is easily constructed from the 1D mesh using tools such as NumPy's &lt;a href="https://numpy.org/doc/stable/reference/generated/numpy.meshgrid.html"&gt;meshgrid&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Back Principal Plane Mesh Spacings&lt;/h3&gt;
&lt;p&gt;In the x-direction, the mesh spacing of the far field coordinate system is&lt;/p&gt;
&lt;p&gt;$$ \Delta x_{\infty} = 2 R / \left( L - 1 \right) = 2 f \text{NA} / \left( L - 1 \right) $$&lt;/p&gt;
&lt;p&gt;In the \( k_x \)-direction, the mesh spacing of the angular spectrum coordinate system is&lt;/p&gt;
&lt;p&gt;$$ \Delta k_x = 2 k_{max} / \left( L - 1 \right) = 2 k_0 \text{NA} / \left( L - 1 \right) $$&lt;/p&gt;
&lt;p&gt;Note the symmetry between these two expressions. One scales with \( f \text{NA} \) and the other \( k_0 \text{NA} \). Recall that these are free parameters of the model.&lt;/p&gt;
&lt;h3&gt;Sample Space Mesh Spacing&lt;/h3&gt;
&lt;p&gt;It is interesting to compute the spacing between mesh elements \( \Delta x \) in the sample space when the fields are eventually computed.&lt;/p&gt;
&lt;p&gt;The sampling angular frequency in the sample space is \( k_S = 2 \pi / \Delta x \).&lt;/p&gt;
&lt;p&gt;The Nyquist-Shannon sampling theory states that the maximum informative angular frequency is \( k_{max} = k_S / 2 \).&lt;/p&gt;
&lt;p&gt;From the previous section, we know that \( k_{max} = \left(L - 1 \right) \Delta k_x / 2 \), and that \( \Delta k_x = 2 k_0 \text{NA} / \left( L - 1 \right) \).&lt;/p&gt;
&lt;p&gt;Combining all the previous expressions and simplifying, we get:&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
k_S &amp;amp;=&amp;amp; 2 k_{max} \\
2 \pi / \Delta x &amp;amp;=&amp;amp; \left(L - 1 \right) \Delta k_x \\
2 \pi / \Delta x &amp;amp;=&amp;amp; \left(L - 1 \right) \left[ 2 k_0 \text{NA} / \left( L - 1 \right) \right] \\
2 \pi / \Delta x &amp;amp;=&amp;amp; \left(L - 1 \right) \left[ 2 \left(2 \pi / \lambda \right) \text{NA} / \left( L - 1 \right) \right]
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;Solving the above expression for \( \Delta x \), we arrive at&lt;/p&gt;
&lt;p&gt;$$ \Delta x = \frac{\lambda}{2 \text{NA}} $$&lt;/p&gt;
&lt;p&gt;which is of course the Abbe diffraction limit.&lt;/p&gt;
&lt;h3&gt;Effect of not Sampling the Origin&lt;/h3&gt;
&lt;p&gt;Herrera and Quinto-Su&lt;sup id="fnref3:2"&gt;&lt;a class="footnote-ref" href="https://kylemdouglass.com/posts/coordinate-systems-for-modeling-microscope-objectives/#fn:2"&gt;2&lt;/a&gt;&lt;/sup&gt; point out that an error will be introduced if we naively apply the FFT to compute the field components in the \( \left( k_x, k_y \right) \) coordinate system because the origin is not sampled, whereas the FFT assumes that we sample the zero frequency component. The effect is that the result of the FFT has a constant phase error that accounts for a half-pixel shift in each direction of the mesh.&lt;/p&gt;
&lt;p&gt;Consider again the 1D mesh example with \(L = 16 \): \( -1.0000, -0.8667, \ldots, -0.0667, 0.0667, \ldots, 0.8667, 1.0000 \)&lt;/p&gt;
&lt;p&gt;In Python and other languages that index arrays starting at 0, the origin is located at \(L / 2 - 0.5 \), i.e. halfway between the samples at index 7 and 8. A lateral shift in Fourier space is equivalent to a phase shift in real space:&lt;/p&gt;
&lt;p&gt;$$ \phi_{shift} \left(X, Y \right) =  -j 2 \pi \frac{0.5}{L} X - j 2 \pi \frac{0.5}{L} Y $$&lt;/p&gt;
&lt;p&gt;where \( X \) and \( Y \) are normalized coordinates.&lt;/p&gt;
&lt;p&gt;At this point, I am uncertain whether the phasor with the above argument needs to be multiplied or divided with the result of the FFT because 1. there are a few typos in the signs for the coordinate system bounds in the manuscript of Herrera and Quinto-Su, and 2. the correction was developed for use in MATLAB, which indexes arrays starting at 1. Once the fields are computed, it would be easy to verify the correct sign of the phase terms following the procedure outlined in Figure 3 of Herrera and Quinto-Su's manuscript.&lt;/p&gt;
&lt;h3&gt;Structure of the Algorithm&lt;/h3&gt;
&lt;p&gt;The algorithm to compute the focus fields will proceed as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;(optional) Propgate the inputs fields from the AS to the back principal plane using paraxial wave propagation&lt;/li&gt;
&lt;li&gt;Input the sampled fields in the back principal plane in the \( \left( x_{\infty}, y_{\infty} \right) \) coordinate system&lt;/li&gt;
&lt;li&gt;Transform the fields to the \( \left( k_x, k_y \right) \) coordinate system&lt;/li&gt;
&lt;li&gt;Compute the fields in the \( \left(x, y, z \right) \) coordinate system using the FFT&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Additional Remarks&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Zero padding the mesh will increase the sample space resolution beyond the Abbe limit, but since the fields remain zero outside of the support, no new information is added.&lt;/li&gt;
&lt;li&gt;On the other hand, zero padding might be required when computing fields going from the sample space to the back principal plane to faithfully reproduce any evanescent components.&lt;/li&gt;
&lt;li&gt;Separating the coordinate system and mesh construction from the calculation of the fields reveals that the two assumptions of the model belong separately to each part. The sine condition is used in the construction of the coordinate systems, whereas energy conservation is used when computing the fields.&lt;/li&gt;
&lt;li&gt;This post did not explain how to compute the fields.&lt;/li&gt;
&lt;li&gt;Herrera and Quinto-Su (and possibly also Novotny and Hecht) appear to use an "effective" focal length which can be obtained by multiplying the one that I use by the sample space refractive index. I prefer my formulation because it is consistent with geometric optics and the well-known expression for the diameter of an objective's entrance pupil. When the fields are calculated, however, I do not yet know whether the arguments of the phasors of the Debye integral will require modification.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Lukas Novotny and Bert Hecht, "Principles of Nano-Optics," Cambridge University Press (2006). &lt;a href="https://doi.org/10.1017/CBO9780511813535"&gt;https://doi.org/10.1017/CBO9780511813535&lt;/a&gt; &lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/coordinate-systems-for-modeling-microscope-objectives/#fnref:1" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/coordinate-systems-for-modeling-microscope-objectives/#fnref2:1" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;Isael Herrera and Pedro A. Quinto-Su, "Simple computer program to calculate arbitrary tightly focused (propagating and evanescent) vector light fields," arXiv:2211.06725 (2022). &lt;a href="https://doi.org/10.48550/arXiv.2211.06725"&gt;https://doi.org/10.48550/arXiv.2211.06725&lt;/a&gt; &lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/coordinate-systems-for-modeling-microscope-objectives/#fnref:2" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/coordinate-systems-for-modeling-microscope-objectives/#fnref2:2" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/coordinate-systems-for-modeling-microscope-objectives/#fnref3:2" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;Marcel Leutenegger, Ramachandra Rao, Rainer A. Leitgeb, and Theo Lasser, "Fast focus field calculations," Opt. Express 14, 11277-11291 (2006). &lt;a href="https://doi.org/10.1364/OE.14.011277"&gt;https://doi.org/10.1364/OE.14.011277&lt;/a&gt; &lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/coordinate-systems-for-modeling-microscope-objectives/#fnref:3" title="Jump back to footnote 3 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:4"&gt;
&lt;p&gt;Sun-Uk Hwang and Yong-Gu Lee, "Simulation of an oil immersion objective lens: A simplified ray-optics model considering Abbe’s sine condition," Opt. Express 16, 21170-21183 (2008). &lt;a href="https://doi.org/10.1364/OE.16.021170"&gt;https://doi.org/10.1364/OE.16.021170&lt;/a&gt; &lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/coordinate-systems-for-modeling-microscope-objectives/#fnref:4" title="Jump back to footnote 4 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><category>microscopy</category><category>optics</category><guid>https://kylemdouglass.com/posts/coordinate-systems-for-modeling-microscope-objectives/</guid><pubDate>Thu, 21 Nov 2024 09:52:48 GMT</pubDate></item><item><title>GitHub CLI Authorization with a Fine-grained Access Token</title><link>https://kylemdouglass.com/posts/github-cli-authorization-with-a-fine-grained-access-token/</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;p&gt;It is a good idea to use fine-grained access tokens for shared PCs in the lab that require access to private GitHub repos so that you can restrict the scope of their use to specific repositories and not use your own personal SSH keys on the shared machines. I am experimenting with the GitHub command line tool &lt;code&gt;gh&lt;/code&gt; to authenticate with GitHub using fine-grained access tokens and make common remote operations on repos easier.&lt;/p&gt;
&lt;p&gt;Today I encountered a subtle problem in the &lt;code&gt;gh&lt;/code&gt; authentication process. If you set the protocol to &lt;code&gt;ssh&lt;/code&gt; during login, then you will not have access to the repos that you granted permissions to in the fine-grained access token. This can lead to a lot of head scratching because it's not at all clear which permissions map to which git operations. In other words, what you think is a specific permissions error with the token is actually an authentication error.&lt;/p&gt;
&lt;p&gt;To avoid the problem, be sure to specify &lt;code&gt;https&lt;/code&gt; and not &lt;code&gt;ssh&lt;/code&gt; as the protocol during authentication:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="go"&gt; echo "$ACCESS_TOKEN" | gh auth login -p https --with-token&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><category>github</category><guid>https://kylemdouglass.com/posts/github-cli-authorization-with-a-fine-grained-access-token/</guid><pubDate>Fri, 04 Oct 2024 12:18:48 GMT</pubDate></item><item><title>Raspberry Pi I2C Quickstart</title><link>https://kylemdouglass.com/posts/raspberry-pi-i2c-quickstart/</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;p&gt;Below are my notes concerning the control of a &lt;a href="https://www.sparkfun.com/products/12918"&gt;Sparkfun MCP4725 12-bit DAC&lt;/a&gt; over I2C with a Raspberry Pi.&lt;/p&gt;
&lt;h2&gt;Rasbperry Pi Setup&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Enable the I2C interface if isn't already with &lt;code&gt;raspi-config&lt;/code&gt;. Verify that the I2C device file(s) are present in &lt;code&gt;/dev/&lt;/code&gt; with &lt;code&gt;ls /dev | grep i2c&lt;/code&gt;. (I had two files: &lt;code&gt;i2c-1&lt;/code&gt; and &lt;code&gt;i2c-2&lt;/code&gt;.)&lt;/li&gt;
&lt;li&gt;Install the &lt;code&gt;i2c-tools&lt;/code&gt; package for debugging I2C interfaces.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="go"&gt;sudo apt update &amp;amp;&amp;amp; sudo apt install -y i2c-tools&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;i2cdetect&lt;/h3&gt;
&lt;p&gt;Attach the DAC to the Raspberry Pi. The pinout is simple:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Raspberry Pi&lt;/th&gt;
&lt;th&gt;MCP4725&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GND&lt;/td&gt;
&lt;td&gt;GND&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3.3V&lt;/td&gt;
&lt;td&gt;Vcc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SCL&lt;/td&gt;
&lt;td&gt;SCL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SDA&lt;/td&gt;
&lt;td&gt;SDA&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Next, run  the command &lt;code&gt;i2cdetect -y 1&lt;/code&gt;. This will check for a device on bus 1 (&lt;code&gt;/dev/i2c-1&lt;/code&gt;) and automatically accept confirmations:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="gp"&gt;leb@raspberrypi:~/$ &lt;/span&gt;i2cdetect&lt;span class="w"&gt; &lt;/span&gt;-y&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;
&lt;span class="go"&gt;     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f&lt;/span&gt;
&lt;span class="go"&gt;00:                         -- -- -- -- -- -- -- --&lt;/span&gt;
&lt;span class="go"&gt;10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --&lt;/span&gt;
&lt;span class="go"&gt;20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --&lt;/span&gt;
&lt;span class="go"&gt;30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --&lt;/span&gt;
&lt;span class="go"&gt;40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --&lt;/span&gt;
&lt;span class="go"&gt;50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --&lt;/span&gt;
&lt;span class="go"&gt;60: 60 -- -- -- -- -- -- -- -- -- -- -- -- -- -- --&lt;/span&gt;
&lt;span class="go"&gt;70: -- -- -- -- -- -- -- --&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Each I2C device must have a unique 7-bit address, i.e. 0x00 to 0x7f. The ranges [0x00, 0x07] and [0x78, 0x7f] are reserved. The above output indicates the DAC is at address 0x60. (Rows are the value of the first hexadecimal number of the address, columns are the second.)&lt;/p&gt;
&lt;h3&gt;i2cset&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;i2cset&lt;/code&gt; is a command line tool that is part of &lt;code&gt;i2c-tools&lt;/code&gt; and that is used to write data to I2C devices. I can set the voltage output of the DAC to 0 as follows:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="go"&gt;i2cset -y 1 0x60 0x40 0x00 0x00 i&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The arguments mean the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-y&lt;/strong&gt; : Auto-confirm&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;1&lt;/strong&gt; : Use the device on bus 1&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;0x60&lt;/strong&gt; : Use the device at address &lt;strong&gt;0x60&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;0x40&lt;/strong&gt; : This is a command byte&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;0x00 0x00&lt;/strong&gt; : These two data bytes specify the DAC output level&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;i&lt;/strong&gt; : This is the write mode. &lt;code&gt;i&lt;/code&gt; means I2C block write: &lt;a href="https://docs.kernel.org/i2c/smbus-protocol.html#i2c-block-write"&gt;https://docs.kernel.org/i2c/smbus-protocol.html#i2c-block-write&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Command byte&lt;/h4&gt;
&lt;p&gt;The command byte is explained on pages 23 and 25 of the &lt;a href="https://ww1.microchip.com/downloads/en/devicedoc/22039d.pdf"&gt;MCP4725 datasheet&lt;/a&gt;. From most-significant to least-significant bits, the bits mean:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;C2&lt;/strong&gt; : command bit&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C1&lt;/strong&gt; : command bit&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C0&lt;/strong&gt; : command bit &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;X&lt;/strong&gt; : unused&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;X&lt;/strong&gt; : unused&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PD1&lt;/strong&gt; : Power down select&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PD0&lt;/strong&gt; : Power down select&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;X&lt;/strong&gt; : unused&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;According to Table 6-2 and Figure 6-2, &lt;code&gt;C2, C1, C0 = 0, 1, 0&lt;/code&gt; identifies the command to write to the DAC register and NOT also to the EEPROM. In normal operation, the power down bits are 0, 0 (page 28).&lt;/p&gt;
&lt;p&gt;So, to write to the DAC register, we want to send &lt;code&gt;0b01000000&lt;/code&gt; which in hexadecimal is &lt;code&gt;0x40&lt;/code&gt;.&lt;/p&gt;
&lt;h4&gt;Data bytes to voltage&lt;/h4&gt;
&lt;p&gt;The data bytes are explained in Figure 6-2 of the datasheet. The first byte contains bits 11-4, and the second byte bits 3-0 in the most-significant bits:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;D11 D10 D9 D8   D7 D6 D5 D4 | D3 D2 D1 D0  X X X X&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;12-bits are used because this is a 12-bit DAC. The mapping between bytes and voltage is:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Data bytes, hex&lt;/th&gt;
&lt;th&gt;Data bytes, decimal&lt;/th&gt;
&lt;th&gt;Voltage&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0x00 0x00&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0xFF 0xF0&lt;/td&gt;
&lt;td&gt;65520&lt;/td&gt;
&lt;td&gt;V_max&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;where V_max is the voltage supplied to the chip's Vcc pin (3.3V in my case). The output step size is \( \Delta V = V_{max} / 4096 \) or about 0.8 mV.&lt;/p&gt;
&lt;h2&gt;Control via Python&lt;/h2&gt;
&lt;p&gt;This is modified from &lt;a href="https://learn.sparkfun.com/tutorials/raspberry-pi-spi-and-i2c-tutorial/all"&gt;Sparkfun's tutorial&lt;/a&gt; and uses the smbus Python bindings. Be aware that the tutorial example has a bug in how it prepares the list of bytes to send to the DAC.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;smbus&lt;/span&gt;


&lt;span class="n"&gt;OUTPUT_MAX&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4095&lt;/span&gt;
&lt;span class="n"&gt;V_MAX&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;3.3&lt;/span&gt;


&lt;span class="k"&gt;def&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;channel&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;device_address&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x60&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;command_byte&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x40&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Output voltage must be expressed as fraction of the maximum in the range [0.0, 1.0]"&lt;/span&gt;

    &lt;span class="n"&gt;bus&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;smbus&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SMBus&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;channel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;output_bytes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;OUTPUT_MAX&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xfff&lt;/span&gt;
    &lt;span class="n"&gt;data_byte_0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;output_bytes&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xff0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;  &lt;span class="c1"&gt;# First data byte&lt;/span&gt;
    &lt;span class="n"&gt;data_bytes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;data_byte_0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;output_bytes&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="c1"&gt;# Second data byte&lt;/span&gt;

    &lt;span class="n"&gt;bus&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write_i2c_block_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;device_address&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;command_byte&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data_bytes&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"__main__"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;float&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.42&lt;/span&gt;
    &lt;span class="n"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sa"&gt;f&lt;/span&gt;&lt;span class="s2"&gt;"Estimated output: &lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;V_MAX&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;Misc.&lt;/h2&gt;
&lt;h3&gt;Basic Calculator &lt;code&gt;bc&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;This is a command line calculator and can be used for hexadecimal, binary, and decimal conversions. Install with &lt;code&gt;apt install bc&lt;/code&gt;.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="gp"&gt;# &lt;/span&gt;Convert&lt;span class="w"&gt; &lt;/span&gt;0x40&lt;span class="w"&gt; &lt;/span&gt;to&lt;span class="w"&gt; &lt;/span&gt;binary
&lt;span class="go"&gt;echo "ibase=16; obase=2; 40" | bc&lt;/span&gt;

&lt;span class="gp"&gt;# &lt;/span&gt;Convert&lt;span class="w"&gt; &lt;/span&gt;0x40&lt;span class="w"&gt; &lt;/span&gt;to&lt;span class="w"&gt; &lt;/span&gt;decimal
&lt;span class="go"&gt;echo "ibase=16; 40" | bc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Note that hexadecimal values must be uppercase, e.g. 0xC7, not 0xc7!&lt;/strong&gt;&lt;/p&gt;</description><category>i2c</category><category>raspberry pi</category><guid>https://kylemdouglass.com/posts/raspberry-pi-i2c-quickstart/</guid><pubDate>Tue, 24 Sep 2024 13:01:45 GMT</pubDate></item></channel></rss>