<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kyle M. Douglass (Posts about ray tracing)</title><link>https://kylemdouglass.com/</link><description></description><atom:link href="https://kylemdouglass.com/categories/ray-tracing.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2025 &lt;a href="mailto:kyle.m.douglass@gmail.com"&gt;Kyle M. Douglass&lt;/a&gt; 
&lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"&gt;
&lt;img alt="Creative Commons License BY-NC-SA"
style="border-width:0; margin-bottom:12px;"
src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"&gt;&lt;/a&gt;</copyright><lastBuildDate>Fri, 06 Jun 2025 06:29:27 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>3D Sequential Optical System Layouts</title><link>https://kylemdouglass.com/posts/3d-sequential-optical-system-layouts/</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;p&gt;I am working on a new feature in my &lt;a href="https://github.com/kmdouglass/cherry"&gt;ray tracer&lt;/a&gt; that will allow users to lay out sequential optical systems in 3D. This is forcing me to think carefully about 3D rigid body transformations in a level of detail that I have never before considered.&lt;/p&gt;
&lt;p&gt;In this post I walk through the mathematics for modeling a pair of flat mirrors that are oriented at different angles. Strictly speaking, the layout can be represented more easily in 2D, but I will treat the problem as if it were the more general 3D case. Emphasis will be placed on specifying rotations in an intuitive manner, which will mean rotations about the optical axis, rather than about a fixed axis in a global reference frame.&lt;/p&gt;
&lt;h2&gt;The Problem&lt;/h2&gt;
&lt;p&gt;The problem that I will consider is depicted as follows:&lt;/p&gt;
&lt;p&gt;&lt;img alt="A system of two flat mirrors whose optical axis forms the figure Z." src="https://kylemdouglass.com/images/sequential-layout-problem-statement.png"&gt;&lt;/p&gt;
&lt;p&gt;The system consists of two flat mirrors whose optical axis forms a "figure Z." The normal of the first mirror is at 30 degrees to the axis, and likewise for the second. The optical axis emerges from the second mirror parallel to the first.&lt;/p&gt;
&lt;p&gt;The questions are:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;How do I construct the system without requiring the user to specify the absolute coordinates of the mirror surfaces?&lt;/li&gt;
&lt;li&gt;How do I represent the local coordinate reference frames for each mirror surface?&lt;/li&gt;
&lt;li&gt;How do I handle transformations between frames?&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Ray Tracing Review&lt;/h3&gt;
&lt;p&gt;As a quick review, the ray tracing algorithm that I implemented was described by Spencer and Murty&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="https://kylemdouglass.com/posts/3d-sequential-optical-system-layouts/#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;. It is loosely follows this pseudo-code:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;each&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;surface&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;system&lt;/span&gt;:
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;each&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;ray&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;ray&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;bundle&lt;/span&gt;:
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;.&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;transform&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;ray&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;coordinates&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;by&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;rotating&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;reference&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;frame&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;into&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;local&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;surface&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;frame&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;.&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;find&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;ray&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;surface&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;intersection&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;point&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;.&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;propagate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;ray&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;to&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;intersection&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;point&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;.&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;perform&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;bounds&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;checking&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;against&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;surface&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;.&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;redirect&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;ray&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;according&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;to&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;laws&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;of&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;refraction&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;reflection&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;.&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;transform&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;ray&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;coordinates&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;by&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;rotating&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;reference&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;frame&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;back&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;into&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;global&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;frame&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Rotations are performed using 3x3 rotation matrices. Ray/surface intersections are found numerically using the Newton-Raphson method, even for spherical surfaces&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="https://kylemdouglass.com/posts/3d-sequential-optical-system-layouts/#fn:2"&gt;2&lt;/a&gt;&lt;/sup&gt;. I computed the expressions for the surface sag and normal vectors for conics and flat surfaces by hand and hard-coded them as functions of the intersection point in the local surface reference frame to avoid having to compute them on-the-fly.&lt;/p&gt;
&lt;p&gt;Looking at the ray trace algorithm, I see three things that are relevant to this discussion:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;There are both global and local reference frames&lt;/li&gt;
&lt;li&gt;Surfaces are iterated over sequentially&lt;/li&gt;
&lt;li&gt;There are rotations, one at the beginning of each loop iteration and one at the end&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Let's explore each one individually, starting with the global and local reference frames.&lt;/p&gt;
&lt;h2&gt;Reference Frames&lt;/h2&gt;
&lt;p&gt;I will use only right-handed reference frames where positive rotations are in the counterclockwise direction.&lt;/p&gt;
&lt;h3&gt;The Global Reference Frame&lt;/h3&gt;
&lt;p&gt;The global reference frame \( \mathbf{G} \) remains fixed. Sometimes it's called the world frame. I denote the coordinate axes of the global frame using \( x \), \( y \), and \( z \).&lt;/p&gt;
&lt;p&gt;&lt;img alt="The global reference frame." src="https://kylemdouglass.com/images/sequential-layout-global-reference-frame.png"&gt;&lt;/p&gt;
&lt;p&gt;By convention, I put its origin at the first non-object surface; this would be at the first mirror in the system of two mirrors I described above&lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="https://kylemdouglass.com/posts/3d-sequential-optical-system-layouts/#fn:3"&gt;3&lt;/a&gt;&lt;/sup&gt;. I also establish the convention that the optical axis between the object and the first surface is parallel to the global z-axis.&lt;/p&gt;
&lt;p&gt;The global frame is important because the orthonormal vectors defining the local and cursor frames (to be explained later) are expressed relative to it.&lt;/p&gt;
&lt;h3&gt;Local Reference Frames&lt;/h3&gt;
&lt;p&gt;Each surface \( i \) has a local reference frame \( \mathbf{L}_i \) whose origin lies at the vertex of the surface. Its coordinate axes are denoted \( x_i^{\prime} \), \( y_i^{\prime} \), and \( z_i^{\prime} \). For flat surfaces, I set the \( z_i^{\prime} \) axis perpendicular to the surface.&lt;/p&gt;
&lt;p&gt;&lt;img alt="The local reference frames of the two mirrors." src="https://kylemdouglass.com/images/sequential-layout-local-reference-frames.png"&gt;&lt;/p&gt;
&lt;p&gt;Notice that the \( x^{\prime} \) axes flip directions when going from mirror 1 to mirror 2. This is done to preserve the right-handedness of the reference frames. More about this will be explained in the next section.&lt;/p&gt;
&lt;h2&gt;Sequential System Models&lt;/h2&gt;
&lt;p&gt;Ray tracing programs for optical design are often divided into two categories: sequential and nonsequential. In sequential ray tracers, rays are traced from one surface to another in the sequence for which they are defined. This means that a ray could pass right through a surface if it is not the next surface in the model sequence.&lt;/p&gt;
&lt;p&gt;Nonsequential ray tracers do not take account of the order in which surfaces are defined. Rays are fired into the world and the intersect whatever the closest object is on their path. Illumination optics often use nonsequential ray tracing, as do rendering engines for cinema.&lt;/p&gt;
&lt;p&gt;My ray tracer is a sequential ray tracer because sequential ray tracing is easier to implement and can be applied to nearly all the use cases that I encounter in the lab.&lt;/p&gt;
&lt;h3&gt;3D Layouts of Sequential Surfaces&lt;/h3&gt;
&lt;p&gt;One possibility to layout sequential surfaces in 3D is to specify the coordinates and orientations of each surface relative to the global frame. This is how one adds surfaces in 3D in the open source Python library &lt;a href="https://github.com/HarrisonKramer/optiland"&gt;Optiland&lt;/a&gt;, for example. In practice, I found that I need to have a piece of paper by my side to work out the positions of each surface independently. This option provides maximum flexibility in surface placement.&lt;/p&gt;
&lt;p&gt;The other possibility that I considered is to leverage the fact that the surfaces are an ordered sequence, and position them in 3D space along the optical axis. The axis can reflect from reflecting surfaces using the law of reflection. Furthermore, any tilt or decenter could be specified relative to this axis. I ultimately chose this solution because I felt that it better matches my mental model of sequential optical systems. It also seems to follow more closely what I do in the lab when I build a system, i.e. add components along an axis that bends through 3D space.&lt;/p&gt;
&lt;h3&gt;The Cursor&lt;/h3&gt;
&lt;p&gt;I created the idea of the cursor to position sequential surfaces in 3D space. A cursor has a 3D position, \( \vec{ t } \left( s \right) \) that is parameterized over the track length \( s \). \( s \) is negative for the object surface, \( s = 0 \) at the first non-object surface, and achieves its greatest value at the final image plane.&lt;/p&gt;
&lt;p&gt;In addition, the cursor has a reference frame attached to it that I denote \( \mathbf{C} \left( s \right) \). The axes of the cursor frame are \( r \), \( u \)  and \( f \), which stand for right, up, and forward, respectively. This nearly matches the &lt;a href="https://dev.epicgames.com/documentation/en-us/uefn/forwardrightup-coordinate-system-in-unreal-editor-for-fortnite"&gt;FRU&lt;/a&gt; coordinate system in game engines such as Unreal, except I take the forward direction to represent the optical axis because I would say that this convention is universal in optical design.&lt;/p&gt;
&lt;p&gt;&lt;img alt="The cursor frames at three different positions along the optical axis." src="https://kylemdouglass.com/images/sequential-layout-cursor-frames.png"&gt;&lt;/p&gt;
&lt;p&gt;Above I show the cursor frame at three different positions along the optical axis \( s_1 &amp;lt; 0 &amp;lt; s_2 &amp;lt; s_3 \). Refracting surfaces will not change the orientation of the cursor frame, but reflecting surfaces will.&lt;/p&gt;
&lt;p&gt;Finally, when \( s \) is exactly equal to a reflecting surface position, I take the orientation of the cursor frame to be the one &lt;strong&gt;before&lt;/strong&gt; reflection. An infinitesimal distance later, the frame reorients by reflecting about the surface normal at the vertex of the surface in its local frame.&lt;/p&gt;
&lt;h4&gt;Convention for Maintaining Right Handedness upon Reflection&lt;/h4&gt;
&lt;p&gt;There is an ambiguity that arises in the cursor frame upon reflection that is best illustrated in the example below:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Ambiguity in the cursor frame upon reflection." src="https://kylemdouglass.com/images/sequential-layout-ambiguity.png"&gt;&lt;/p&gt;
&lt;p&gt;In panel a, the cursor is incident upon a mirror with its frame's forward direction antiparallel to the mirror's normal vector. There are two equally valid choices when defining the cursor frame after reflection. In panel b, the cursor frame is rotated about the up direction, whereas in panel c it is rotated about the right direction. This means that there is no fundamentally correct way to position the cursor frame after reflection. We must choose a convention and stick with it.&lt;/p&gt;
&lt;p&gt;Reflections of the cursor frame are handled in two steps:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Reflect the frame&lt;/li&gt;
&lt;li&gt;Adjust the results to maintain right handedness and address the ambiguity illustrated above&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The vector law of reflection is used to compute the new \( \hat{ r } \), \( \hat{ u } \), and \( \hat{ f } \) unit vectors for any general angle of incidence of the cursor frame upon a reflecting surface:&lt;/p&gt;
&lt;p&gt;$$\begin{equation}
\hat{ f }^{\prime} = \hat{ f } - 2 \left( \hat{ f } \cdot \hat{ n } \right) \hat{ n }
\end{equation}$$&lt;/p&gt;
&lt;p&gt;where \( \hat{ n } \) is the surface's unit normal vector. The same applies for the right and up unit vectors.&lt;/p&gt;
&lt;p&gt;After reflection, I perform a check for right handedness. By convention, I maintain the direction of the up unit vector because many optical systems are laid out in 2D and their elements are rotated about this direction. This convention means that the right unit vector must be flipped:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;cross&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;right&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;up&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;·&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;forward&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;:
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nv"&gt;right&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;right&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The cross product between the right and up directions must point in the forward direction if the system is right handed. "Pointing in the forward direction" means that the dot product of the result with the forward unit vector must be greater than zero. The conditonal in the pseudocode above checks whether this is not indeed the case and flips the right unit vector if necessary.&lt;/p&gt;
&lt;h2&gt;Transformations between Reference Frames&lt;/h2&gt;
&lt;p&gt;There are two different transformations required by the ray trace algorithm:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;From the global frame to a surface local frame&lt;/li&gt;
&lt;li&gt;From a surface local frame to the global frame&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Because the system is laid out relative to the cursor frame, I need to chain together two rotations, one from the global to the cursor frame, and one from the cursor to the local frame.&lt;/p&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;p&gt;Let's say that the second mirror has a diameter of 25.4 mm, and that the mirrors are separated by \( \| \vec{ t } \left( s_2 \right) \| = 100 \, mm \). I want to find the transformation from the global frame coordinates at a point on the bottom edge of the mirror to the local frame coordinates, which is \( y_2^{\prime} = -12.7 \, mm \). The image below illustrates the geometry that will be used for this example.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Example geometry for transforming from the global frame to the local frame via the cursor frame." src="https://kylemdouglass.com/images/sequential-layout-example-geometry.png"&gt;&lt;/p&gt;
&lt;p&gt;From relatively straightforward trigonmetry&lt;sup id="fnref:4"&gt;&lt;a class="footnote-ref" href="https://kylemdouglass.com/posts/3d-sequential-optical-system-layouts/#fn:4"&gt;4&lt;/a&gt;&lt;/sup&gt; we get the global frame coordinates of both \( {}^{\mathbf{G}}\vec{ t } \left( s_2 \right) \) and the point we are trying to find, \( {}^{\mathbf{G}}\vec{ p } \). (Vectors preceded by superscripts with reference frame names indicate the coordinate system they are being referred to.)&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
 {}^{\mathbf{G}}\vec{ t } \left( s_2 \right) = \left(
  \begin{array}{c}
    0 \\
    50 \sqrt{ 3 } \\
    -50
  \end{array}
\right)
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
 {}^{\mathbf{G}}\vec{ p } = \left(
  \begin{array}{c}
    0 \\
    43.65 \sqrt{ 3 } \\
    -56.35
  \end{array}
\right)
\end{eqnarray}$$&lt;/p&gt;
&lt;h4&gt;Step 1: Translate from the Global Origin to the Cursor Frame&lt;/h4&gt;
&lt;p&gt;The first step in computing \( {}^{\mathbf{ C }} \vec{ p } \) is to translate from the origin of the global frame to the position of cursor.&lt;/p&gt;
&lt;p&gt;$$ {}^{\mathbf{G}}\vec{ p } - {}^{\mathbf{G}}\vec{ t } \left( s_2 \right)  =  (0, -6.35 \sqrt{3}, -6.35)^{ \mathrm{ T }}$$&lt;/p&gt;
&lt;h4&gt;Step 2: Rotate into the Cursor Frame&lt;/h4&gt;
&lt;p&gt;A rotation from the global frame into the cursor frame can be achieved by taking the \( \hat{ r } \), \( \hat{ u } \), and \( \hat{ f } \) unit vectors that define the cursor frame in the global coordinate system and making them the columns of a \( 3 \times 3 \) rotation matrix. At the second mirror, this matrix is:&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
R_{GC} \left( \theta = 30^{ \circ } \right) = \left(
  \begin{array}{ccc}
    -1 &amp;amp; 0 &amp;amp; 0 \\
    0 &amp;amp; 1 / 2 &amp;amp; \sqrt{ 3 } / 2 \\
    0 &amp;amp; \sqrt{ 3 } / 2 &amp;amp; -1 / 2
  \end{array}
\right)
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;If this is not clear, consider that the columns of a rotation matrix represent the basis vectors of the coordinate system after rotation, but expressed in the original (global) frame's coordinate system. Also, from the diagram above, \( \hat{ u } \left( s_2 \right) = ( 0, 1 / 2, \sqrt{ 3 } / 2)^{ \mathrm{ T }} \) and \( \hat{ f } \left( s_2 \right) = ( 0, \sqrt{ 3 } / 2, - 1 / 2)^{ \mathrm{ T }}\), which are the second and third columns of the matrix.&lt;/p&gt;
&lt;p&gt;The rotation into the cursor frame is the product between the rotation matrix and the difference \( {}^{\mathbf{G}}\vec{ p } - {}^{\mathbf{G}}\vec{ t } \left( s_2 \right) \):&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
{}^{\mathbf{ C }} \vec{ p } = R_{GC} \left[ {}^{\mathbf{G}}\vec{ p } - {}^{\mathbf{G}}\vec{ t } \left( s_2 \right) \right] = \left(
  \begin{array}{ccc}
    -1 &amp;amp; 0 &amp;amp; 0 \\
    0 &amp;amp; 1 / 2 &amp;amp; \sqrt{ 3 } / 2 \\
    0 &amp;amp; \sqrt{ 3 } / 2 &amp;amp; -1 / 2
  \end{array}
\right) \left(
  \begin{array}{c}
    0 \\
    -6.35 \sqrt{ 3 } \\
    -6.35
  \end{array}
\right) = \left(
  \begin{array}{c}
    0 \\
    -6.35 \sqrt{ 3 } \\
    -6.35
  \end{array}
\right)
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;At first, I thought I had made a mistake when I did this calculation because the vector is unchanged after rotation. However, as illustrated below, you can see that the relative lengths of the projections of \( {}^{\mathbf{G}}\vec{ p } - {}^{\mathbf{G}}\vec{ t } \left( s_2 \right) \) onto the \( u \) and \( f \) axes make sense.&lt;/p&gt;
&lt;p&gt;&lt;img alt="A simplified schematic showing the projection of difference vector onto the -u and -f axes." src="https://kylemdouglass.com/images/sequential-layout-example-global-to-cursor.png"&gt;&lt;/p&gt;
&lt;p&gt;As it turns out, I inadvertently chose an eigenvector of the rotation matrix as an example; any general point will in fact change its coordinates when moving from the global to the cursor frame. For example, if we try to rotate a vector that is antiparallel to the global z-axis, i.e. \( {}^{\mathbf{G}}\vec{ p } - {}^{\mathbf{G}}\vec{ t } \left( s_2 \right) = ( 0, 0, -1 )^{ \mathrm{ T } }\), then it will become&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
R_{GC} \left[ {}^{\mathbf{G}}\vec{ p } - {}^{\mathbf{G}}\vec{ t } \left( s_2 \right) \right] = \left(
  \begin{array}{ccc}
    -1 &amp;amp; 0 &amp;amp; 0 \\
    0 &amp;amp; 1 / 2 &amp;amp; \sqrt{ 3 } / 2 \\
    0 &amp;amp; \sqrt{ 3 } / 2 &amp;amp; -1 / 2
  \end{array}
\right) \left(
  \begin{array}{c}
    0 \\
    0 \\
    -1
  \end{array}
\right) = \left(
  \begin{array}{c}
    0 \\
    -0.8660 \\
    -0.5
  \end{array}
\right)
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;in the cursor frame.&lt;/p&gt;
&lt;h4&gt;Step 3: Rotate into the Surface Local Frame&lt;/h4&gt;
&lt;p&gt;For the final step, I need to compose a rotation matrix from a sequence of three rotations. To do this well, I need to be very clear about what types of rotations I am performing and their sequence.&lt;/p&gt;
&lt;h5&gt;Active vs. Passive Rotations&lt;/h5&gt;
&lt;p&gt;The difference between active and passive rotations are illustrated below for a 45 degree rotation about the right axis.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Active vs. passive rotations" src="https://kylemdouglass.com/images/sequential-layout-active-vs-passive.png"&gt;&lt;/p&gt;
&lt;p&gt;Active rotations specify the rotation of a point relative to a fixed reference frame; passive rotations specify the rotation of a reference frame, keeping the point fixed. And pay attention here: the right axis points into the screen, so a positive rotation would be clockwise when viewed from the perspective drawn above. &lt;/p&gt;
&lt;p&gt;What are the corresponding rotation matrices? Here, I found that the internet is absolutely littered with wrong answers, including on sites like Wikipedia. I even get different answers from LLMs depending on when I ask. Therefore, I am including them here as a gift to my future self.&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;active&lt;/strong&gt; rotation matrices about the x (right), y (up), and z (forward) axes are:&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
R_x \left( \theta \right) = \left(
  \begin{array}{ccc}
    1 &amp;amp; 0 &amp;amp; 0 \\
    0 &amp;amp; \cos \theta &amp;amp; - \sin \theta \\
    0 &amp;amp; \sin \theta &amp;amp; \cos \theta
  \end{array}
\right)
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
R_y \left( \psi \right) = \left(
  \begin{array}{ccc}
    \cos \psi &amp;amp; 0 &amp;amp; \sin \psi \\
    0 &amp;amp; 1 &amp;amp; 0 \\
    - \sin \psi &amp;amp; 0 &amp;amp; \cos \psi
  \end{array}
\right)
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
R_z \left( \phi \right) = \left(
  \begin{array}{ccc}
    \cos \phi &amp;amp; - \sin \phi &amp;amp; 0 \\
    \sin \phi &amp;amp; \cos \phi &amp;amp; 0 \\
    0 &amp;amp; 0 &amp;amp; 1
  \end{array}
\right)
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;passive&lt;/strong&gt; rotation matrices about the x (right), y (up), and z (forward) axes are:&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
R_x \left( \theta \right) = \left(
  \begin{array}{ccc}
    1 &amp;amp; 0 &amp;amp; 0 \\
    0 &amp;amp; \cos \theta &amp;amp; \sin \theta \\
    0 &amp;amp; - \sin \theta &amp;amp; \cos \theta
  \end{array}
\right)
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
R_y \left( \psi \right) = \left(
  \begin{array}{ccc}
    \cos \psi &amp;amp; 0 &amp;amp; - \sin \psi \\
    0 &amp;amp; 1 &amp;amp; 0 \\
    \sin \psi &amp;amp; 0 &amp;amp; \cos \psi
  \end{array}
\right)
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
R_z \left( \phi \right) = \left(
  \begin{array}{ccc}
    \cos \phi &amp;amp; \sin \phi &amp;amp; 0 \\
    - \sin \phi &amp;amp; \cos \phi &amp;amp; 0 \\
    0 &amp;amp; 0 &amp;amp; 1
  \end{array}
\right)
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;Notice that all that changes between these two types of rotations is the location of a negative sign on the \( \sin \) terms.&lt;/p&gt;
&lt;p&gt;I found that a useful way to remember whether a matrix represents an active or passive rotation is as follows. Take for example the +45 degree rotation of the vector \( ( 0, 0, 1 )^{ \mathrm{ T } } \) about the right direction illustrated above. You can see that an active rotation should result in a negative \( u \) and a positive \( f \) component. This means&lt;sup id="fnref:6"&gt;&lt;a class="footnote-ref" href="https://kylemdouglass.com/posts/3d-sequential-optical-system-layouts/#fn:6"&gt;6&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
\left(
  \begin{array}{ccc}
    1 &amp;amp; 0 &amp;amp; 0 \\
    0 &amp;amp; 1 / \sqrt{ 2 } &amp;amp; - 1 / \sqrt{ 2 } \\
    0 &amp;amp; 1 / \sqrt{ 2 } &amp;amp; 1 / \sqrt{ 2 }
  \end{array}
\right) \left(
  \begin{array}{c}
    0 \\
    0 \\
    1
  \end{array}
\right) = \left(
  \begin{array}{c}
    0 \\
    - 1 / \sqrt{ 2 } \\
    1 / \sqrt{ 2 }
  \end{array}
\right)
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;The passive rotation should result in positive values for both the \( u^{ \prime } \) and \( f^{ \prime } \) components:&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
\left(
  \begin{array}{ccc}
    1 &amp;amp; 0 &amp;amp; 0 \\
    0 &amp;amp; 1 / \sqrt{ 2 } &amp;amp; 1 / \sqrt{ 2 } \\
    0 &amp;amp; - 1 / \sqrt{ 2 } &amp;amp; 1 / \sqrt{ 2 }
  \end{array}
\right) \left(
  \begin{array}{c}
    0 \\
    0 \\
    1
  \end{array}
\right) = \left(
  \begin{array}{c}
    0 \\
    1 / \sqrt{ 2 } \\
    1 / \sqrt{ 2 }
  \end{array}
\right)
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;I can do a similar check for the other directions to verify the other matrices.&lt;/p&gt;
&lt;h5&gt;Extrinsic vs. Intrinsic Rotations&lt;/h5&gt;
&lt;p&gt;I found these easier to understand than active and passive rotations. Extrinsic rotations are rotations that are always about a fixed global reference frame. On the other hand, intrinsic rotations are about the intermediate frames that result from a single rotation. So if I rotate about the \( f \) axis, then the \( r \) and \( u \) axes will be rotated, resulting in an intermediate \( r^{ \prime }u^{ \prime }f^{ \prime } \) frame. The next rotation will be about one of these intermediate axes.&lt;/p&gt;
&lt;p&gt;The confusing thing about these two types of rotations is the order in which the rotation matrices are applied to a vector. An &lt;strong&gt;extrinsic&lt;/strong&gt; rotation of a vector \( \vec{ v } \) about \( r \), then \( u \), then \( f \) is written as:&lt;/p&gt;
&lt;p&gt;$$ R_f R_u R_r \vec{ v} $$&lt;/p&gt;
&lt;p&gt;which follows the usual commutativity rules of matrix multiplication. An &lt;strong&gt;intrinsic&lt;/strong&gt; rotation of a vector \( \vec{ v } \) about \( r \), then \( u^{ \prime } \), then \( f^{ \prime \prime } \), on the other hand is written as:&lt;/p&gt;
&lt;p&gt;$$ R_r R_u R_f \vec{ v} $$&lt;/p&gt;
&lt;p&gt;So even though the rotation about the right direction is performed first, we multiply the vector first by the rotation matrix about the \( f \) direction in the second intermediate frame.&lt;/p&gt;
&lt;p&gt;All of this might seem confusing and lead one to wonder why they would want to use intrinsic rotations, but actually they are much more intuitive than extrinsic rotations and make a lot of sense when laying out an optical system. For example, if I have a two-axis mirror mount and I rotate the mirror about the vertical axis, a horizontal rotation that follows will be about the axis in the newly rotated frame, not the global laboratory frame. In any case, a sequence of three extrinsic rotations and three intrinsic rotations through the same angles will produce the same result so long as the order of the rotation matrices is correct.&lt;/p&gt;
&lt;h5&gt;Euler Angles and Rotation Sequences&lt;/h5&gt;
&lt;p&gt;The most important thing I learned about Euler angles is that they are completely meaningless unless you also specify a rotation sequence. Additionally, the internet is full of resources about the distinction between proper and improper Euler angles. The gist of what I learned here is that proper Euler angles are really a distraction to scientists and engineers because they rely on rotation sequences in which one of the axes is used twice. More useful are what aerospace engineers sometimes refer to as the Tait-Bryan angles, which are the rotation angles associated with sequences like \( z-y^{ \prime }-x^{ \prime \prime } \) or \( x-y-z \).&lt;/p&gt;
&lt;p&gt;Now, there is one point here that is worth making and that is relevant to optical system layout: &lt;strong&gt;rotations about \( f \), the forward direction, into the local frame are best performed last in the sequence.&lt;/strong&gt; To understand why, consider a cylindrical lens with an axis parallel to the local \( z' \) direction. If we perform an intrinsic rotation about the cursor's \( f \) direction first and then try to adjust its tip or tilt, we will be doing so about axes that are rotated such that its tip and tilt become coupled with respect to the global frame. When aligning such systems, no one expects that rotation of a cylindrical lens about its axis will change the way that the tip and tilt adjustors on a lens mount work.&lt;/p&gt;
&lt;p&gt;For all these reasons, I choose an intrinsic sequence \(r - u^{ \prime } - f^{{ \prime \prime} } \) of passive rotations with Euler angles \( \theta \), \( \psi \), and \( \phi \), respectively. The corresponding rotation matrix is:&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
R_{ \mathbf{ CL } } ( \theta, \psi, \phi ) = R_r ( \theta ) R_u ( \psi ) R_f ( \phi ) = \left(
  \begin{array}{ccc}
    \cos \phi \cos \psi &amp;amp; \sin \phi \cos \psi &amp;amp; - \sin \psi \\
    - \sin \phi \cos \theta + \sin \psi \sin \theta \cos \phi &amp;amp; \sin \phi \sin \psi \sin \theta + \cos \phi \cos \theta &amp;amp; \sin \theta \cos \psi \\
    \sin \phi \sin \theta + \sin \psi \cos \phi \cos \theta &amp;amp; \sin \phi \sin \psi \cos \theta - \sin \theta \cos \phi &amp;amp; \cos \psi \cos \theta 
  \end{array}
\right)
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;And finally, the transformation of the point on the mirror from the global to the surface local frame is:&lt;/p&gt;
&lt;p&gt;$$ {}^{ \mathbf{ L }}\vec{p} = R_{ CL }R_{ GC } \left[ {}^{\mathbf{G}}\vec{ p } - {}^{\mathbf{G}}\vec{ t } \left( s_2 \right) \right] $$&lt;/p&gt;
&lt;h5&gt;The Solution to the Example&lt;/h5&gt;
&lt;p&gt;Does this give the correct result in the above example? Well, the mirror is rotated +30 degrees about the right direction, so the cursor-to-local rotation matrix is:&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
R_{CL} \left( \theta  = 30^{ \circ },  \psi = 0, \phi = 0 \right) = \left(
  \begin{array}{ccc}
    1 &amp;amp; 0 &amp;amp; 0 \\
    0 &amp;amp; \sqrt{ 3 } / 2 &amp;amp; 1 / 2 \\
    0 &amp;amp; - 1 / 2 &amp;amp; \sqrt{ 3 } / 2
  \end{array}
\right)
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;From earlier, the vector representing the point in the cursor frame is \( ( 0, -6.35 \sqrt{ 3 }, -6.35 )^{ \mathrm{ T } } \). Their product gives the final answer:&lt;/p&gt;
&lt;p&gt;$$\begin{eqnarray}
{}^{ \mathbf{ L } }\vec{ p } = \left(
  \begin{array}{ccc}
    1 &amp;amp; 0 &amp;amp; 0 \\
    0 &amp;amp; \sqrt{ 3 } / 2 &amp;amp; 1 / 2 \\
    0 &amp;amp; - 1 / 2 &amp;amp; \sqrt{ 3 } / 2
  \end{array}
\right) \left(
  \begin{array}{c}
    0 \\
    -6.35 \sqrt{ 3 } \\
    -6.35
  \end{array}
\right) = \left(
\begin{array}{c}
    0 \\
    -12.7 \\
    0
  \end{array}
\right)
\end{eqnarray}$$&lt;/p&gt;
&lt;p&gt;This is exactly as expected, as we wanted to get a point on the bottom of the 25.4 mm diameter mirror in its local frame.&lt;/p&gt;
&lt;h4&gt;Step 4: Rotate back from the Surface Local to the Global Frame&lt;/h4&gt;
&lt;p&gt;I need to go back to the global frame at the end of each iteration for a ray trace. Fortunately, it's easy to undo a rotation because the inverse of a rotation matrix is just its transpose. I also need to swap the order of the matrices when taking the inverse, and add back the offset from the origin of the global system. This means:&lt;/p&gt;
&lt;p&gt;$${}^{\mathbf{ G } }\vec{ p } = R_{GC}^{ \mathrm{ T} } R_{CL}^{ \mathrm{ T} } {}^{\mathbf{ L } }\vec{ p } + {}^{\mathbf{ G }} \vec{ t } (s_2) $$&lt;/p&gt;
&lt;p&gt;I plugged in the numbers in Python and verified that I get the original point back.&lt;/p&gt;
&lt;p&gt;This should be all I need to know to implement 3D sequential optical system layouts in my ray tracer.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;G. H. Spencer and M. V. R. K. Murty, "General Ray-Tracing Procedure," J. Opt. Soc. Am. 52, 672-678 (1962). &lt;a href="https://doi.org/10.1364/JOSA.52.000672"&gt;https://doi.org/10.1364/JOSA.52.000672&lt;/a&gt;. &lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/3d-sequential-optical-system-layouts/#fnref:1" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;Ray/surface intersections with spherical surfaces can be found analytically using the quadratic equation with only minor caveats considering stability issues due to floating point arithmetic. This would likely be faster than using Newton-Raphson. However, a general system contains both spherical and non-spherical surfaces, and I was concerned that checking each surface type would result in a performance hit due to branch prediction failures by the processor. I could probably have found a way around this by deciding ahead of time which algorithm to use to determine the intersection for each surface before entering the main ray tracing loop, but during initial development I decided to just use Newton-Raphson for everything because doing so resulted in very simple code. (Thanks to Andy York for telling me about the numerical instabilities when using the quadratic equation. See Chapter 7 here: &lt;a href="https://www.realtimerendering.com/raytracinggems/rtg/index.html"&gt;https://www.realtimerendering.com/raytracinggems/rtg/index.html&lt;/a&gt;.) &lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/3d-sequential-optical-system-layouts/#fnref:2" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;The object plane is the flat surface perpendicular to the optical axis in which the object lies. It is always at surface index 0 in my convention. &lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/3d-sequential-optical-system-layouts/#fnref:3" title="Jump back to footnote 3 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:4"&gt;
&lt;p&gt;Since the only angles involved are \( 30^{ \circ} \) and \( 60^{ \circ } \), I used a 30-60-90 triangle of lengths 1, \( \sqrt{ 3 } \), and 2, respectively to compute the cosines and sines. &lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/3d-sequential-optical-system-layouts/#fnref:4" title="Jump back to footnote 4 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:5"&gt;
&lt;p&gt;Passive rotations result in a rotation of the coordinate axes, keeping a point fixed; active rotations rotate a point about a set of axes. &lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/3d-sequential-optical-system-layouts/#fnref:5" title="Jump back to footnote 5 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:6"&gt;
&lt;p&gt;The cosine and sine of 45 degrees are both \( 1 / \sqrt{ 2 } \). &lt;a class="footnote-backref" href="https://kylemdouglass.com/posts/3d-sequential-optical-system-layouts/#fnref:6" title="Jump back to footnote 6 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><category>optics</category><category>ray tracing</category><guid>https://kylemdouglass.com/posts/3d-sequential-optical-system-layouts/</guid><pubDate>Thu, 05 Jun 2025 09:26:25 GMT</pubDate></item><item><title>Data Type Alignment for Ray Tracing in Rust</title><link>https://kylemdouglass.com/posts/data-type-alignment-for-ray-tracing-in-rust/</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;p&gt;I would like to clean up my 3D ray trace routines for my &lt;a href="https://www.github.com/kmdouglass/cherry"&gt;Rust-based optical design library&lt;/a&gt;. The proof of concept (PoC) is finished and I now I need to make the code easier to modify to better support the features that I want to add on the frontend. I suspect that I might be able to make some performance gains as well during refactoring. Towards this end, I want to take a look at my ray data type from the perspective of making it CPU cache friendly.&lt;/p&gt;
&lt;p&gt;One of the current obstacles to adding more features to the GUI (for example color selection for different ray bundles) is how I handle individual rays. For the PoC it was fastest to add two additional fields to each ray to track where they come from and whether they are terminated:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Vec3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;f64&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Ray&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Vec3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;dir&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Vec3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;terminated&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;field_id&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;usize&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;A ray is just two, 3-element arrays of floats that specify the coordinates of a point on the ray and its direction cosines. I have additionally included a boolean flag to indicate whether the ray has terminated, i.e. gone out-of-bounds of the system or failed to converge during calculation of the intersection point with a surface.&lt;/p&gt;
&lt;p&gt;A ray fan is a collection of rays and is specified by a 3-tuple of wavelength, axis, and field; &lt;code&gt;field_id&lt;/code&gt; really should not belong to an individual Ray because it can be stored along with the set of all rays for the current ray fan. I probably added it because it was the easiest thing to do at the time to get the application working.&lt;/p&gt;
&lt;h2&gt;A deeper look into the Ray struct&lt;/h2&gt;
&lt;h3&gt;Size of a ray&lt;/h3&gt;
&lt;p&gt;Let's first look to see how much space the Ray struct occupies.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="cp"&gt;#[derive(Debug)]&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Vec3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;f64&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cp"&gt;#[derive(Debug)]&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Ray&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Vec3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;dir&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Vec3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;terminated&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;field_id&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;usize&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="fm"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Size of ray: {:?}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;size_of&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Ray&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;Ray&lt;/code&gt; struct occupies 64 bytes in memory. Does this make sense?&lt;/p&gt;
&lt;p&gt;The sizes of the individual fields are:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Field&lt;/th&gt;
&lt;th&gt;Size, bytes&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;pos&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dir&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;terminated&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;field_id&lt;/td&gt;
&lt;td&gt;8*&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;pos&lt;/code&gt; and &lt;code&gt;dir&lt;/code&gt; are each 24 bytes because they are each composed of three 64-bit floats and 8 bits = 1 byte. &lt;code&gt;terminated&lt;/code&gt; is only one byte because it is a boolean. &lt;code&gt;field_id&lt;/code&gt; is a &lt;a href="https://doc.rust-lang.org/std/primitive.usize.html"&gt;usize&lt;/a&gt;, which means that it depends on the compilation target. On 64-bit targets, such as x86_64, it is 64 bits = 8 bytes in size.&lt;/p&gt;
&lt;p&gt;Adding the sizes in the above table gives 57 bytes, not 64 bytes as was output from the example code. Why is this?&lt;/p&gt;
&lt;h3&gt;Alignment and padding&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Data_structure_alignment"&gt;Alignment&lt;/a&gt; refers to the layout of a data type in memory and how it is accessed. CPUs read memory in chunks that are equal in size to the &lt;a href="https://en.wikipedia.org/wiki/Word_(computer_architecture)"&gt;word size&lt;/a&gt;. Misaligned data is inefficient to access because the CPU requires more cycles than is necessary to fetch the data.&lt;/p&gt;
&lt;p&gt;Natural alignment refers to the most efficient alignment of a data type for CPU access. To achieve natural alignment, a compiler can introduce padding between fields of a struct so that the memory address of a field or datatype is a multiple of the field's/data type's alignment.&lt;/p&gt;
&lt;p&gt;As an example of misalignment, consider a 4-byte integer and that starts at memory address 5. The CPU has 32-bit memory words. To read the data, the CPU must:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;read bytes 4-7,&lt;/li&gt;
&lt;li&gt;read bytes 8-11,&lt;/li&gt;
&lt;li&gt;and combine the relevant parts of both reads to get the 4 bytes, i.e. bytes 5 - 8.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Notice that we must specify the memory word size to determine whether a data type is misaligned.&lt;/p&gt;
&lt;p&gt;Here is an important question: &lt;strong&gt;why can't the CPU just start reading from memory address 5?&lt;/strong&gt; The answer, as far as I can tell, is that it just can't. This is not how the CPU, RAM, and memory bus are wired.&lt;/p&gt;
&lt;h3&gt;Alignment in Rust&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://doc.rust-lang.org/reference/type-layout.html#size-and-alignment"&gt;Alignment in Rust&lt;/a&gt; is defined as follows:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The alignment of a value specifies what addresses are valid to store the value at. A value of alignment n must only be stored at an address that is a multiple of n.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="https://doc.rust-lang.org/reference/type-layout.html#the-rust-representation"&gt;The Rust compiler only guarantees the following&lt;/a&gt; when it comes to padding fields in structs:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;The fields are properly aligned.&lt;/li&gt;
&lt;li&gt;The fields do not overlap.&lt;/li&gt;
&lt;li&gt;The alignment of the type is at least the maximum alignment of its fields.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;So for my &lt;code&gt;Ray&lt;/code&gt; data type, its alignment is 8 because the maximum alignment of its fields is 8 bytes. (&lt;code&gt;pos&lt;/code&gt; and &lt;code&gt;dir&lt;/code&gt; are composed of 8-byte floating point numbers). The addresses of its fields are:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ray&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Ray&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Vec3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;dir&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Vec3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;terminated&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;false&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;field_id&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;unsafe&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="fm"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Address of ray.pos: {:p}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;addr_of&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ray&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="fm"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Address of ray.dir: {:p}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;addr_of&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ray&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dir&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="fm"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Address of ray.terminated: {:p}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;addr_of&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ray&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;terminated&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="fm"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Address of ray.field_id: {:p}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;addr_of&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ray&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;field_id&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I got the following results, which will vary from system-to-system and probably run-to-run:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="go"&gt;Address of ray.pos: 0x7fff076c6b50&lt;/span&gt;
&lt;span class="go"&gt;Address of ray.dir: 0x7fff076c6b68&lt;/span&gt;
&lt;span class="go"&gt;Address of ray.terminated: 0x7fff076c6b88&lt;/span&gt;
&lt;span class="go"&gt;Address of ray.field_id: 0x7fff076c6b80&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So the &lt;code&gt;pos&lt;/code&gt; field comes first at address &lt;code&gt;0x6b50&lt;/code&gt; (omitting the most significant hexadecimal digits). Then, 24 bytes later, comes &lt;code&gt;dir&lt;/code&gt; at address &lt;code&gt;0x6b68&lt;/code&gt;. Note that the difference is hexadecimal 0x18, which is decimal 16 + 8 = 24! So &lt;code&gt;pos&lt;/code&gt; really occupies 24 bytes like we previously calculated.&lt;/p&gt;
&lt;p&gt;Next comes &lt;code&gt;field_id&lt;/code&gt; and not &lt;code&gt;terminated&lt;/code&gt;. It is &lt;code&gt;0x6b80 - 0x6b68 = 0x0018&lt;/code&gt;, or 24 bytes after &lt;code&gt;dir&lt;/code&gt; like before. So far we have no padding, but the compiler did swap the order of the fields. Finally, &lt;code&gt;terminated&lt;/code&gt; is 8 bytes after &lt;code&gt;field_id&lt;/code&gt; because &lt;code&gt;field_id&lt;/code&gt; is 8-byte aligned. This means that the Rust compiler must have placed 7 bytes of padding after the &lt;code&gt;terminated&lt;/code&gt; field.&lt;/p&gt;
&lt;h2&gt;What makes a good data type?&lt;/h2&gt;
&lt;p&gt;As I mentioned, I already know that &lt;code&gt;field_id&lt;/code&gt; shouldn't belong to the ray for reasons related to data access by the programmer. So the reason for removing it from the &lt;code&gt;Ray&lt;/code&gt; struct is not related to performance. But what about the &lt;code&gt;terminated&lt;/code&gt; bool? Well, in this case, it's resulting in 7 extra bytes of padding for each ray!&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="cp"&gt;#[derive(Debug)]&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Vec3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;f64&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cp"&gt;#[derive(Debug)]&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Ray&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Vec3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;dir&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Vec3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;terminated&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ray&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Ray&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Vec3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;dir&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Vec3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;terminated&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;false&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="fm"&gt;println!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Size of ray: {:?}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;size_of&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Ray&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This program prints &lt;code&gt;Size of ray : 56&lt;/code&gt;, but 24 + 24 + 1 = 49. In both versions we waste 7 bytes.&lt;/p&gt;
&lt;h3&gt;Fitting a Ray into the CPU cache&lt;/h3&gt;
&lt;p&gt;Do I have a good reason to remove &lt;code&gt;terminated&lt;/code&gt; from the &lt;code&gt;Ray&lt;/code&gt; struct because it wastes space? Consider the following:&lt;/p&gt;
&lt;p&gt;We want as many &lt;code&gt;Ray&lt;/code&gt; instances as possible to fit within a CPU cache line if we want to maximize performance. (Note that I'm not saying that we necessarily want to maximize performance because that comes with tradeoffs.) Each CPU core on my AMD Ryzen 7 has a 64 kB L1 cache with 64 byte cache lines. This means that I can fit only 1 of the current version of &lt;code&gt;Ray&lt;/code&gt; into each cache line for a total of 64 kB / 64 bytes = 1024 rays maximum in the L1 cache of each core. If I remove &lt;code&gt;field_size&lt;/code&gt; and &lt;code&gt;terminated&lt;/code&gt;, then the size of a ray becomes 48 bytes. Unfortunately, this means that only one &lt;code&gt;Ray&lt;/code&gt; instance fits in a cache line, just as before with a 64 byte &lt;code&gt;Ray&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But, if I also reduce my precision to 32-bit floats, then the size of a &lt;code&gt;Ray&lt;/code&gt; becomes 6 * 4 = 24 bytes and I have doubled the number of rays that fit in L1 cache.&lt;/p&gt;
&lt;p&gt;Now what if I reduced the precision but kept &lt;code&gt;terminated&lt;/code&gt;? Then I get 6 * 4 + 8 = 32 bytes per Ray and I still have 2 rays per cache line.&lt;/p&gt;
&lt;p&gt;I conclude that there is no reason to remove &lt;code&gt;terminated&lt;/code&gt; for performance reasons. Reducing my floating point precision would produce a more noticeable effect on the cache locality of the &lt;code&gt;Ray&lt;/code&gt; data type.&lt;/p&gt;
&lt;h2&gt;Does all of this matter?&lt;/h2&gt;
&lt;p&gt;My Ryzen 7 laptop can trace about 600 rays through 3 surfaces in 380 microseconds with Firefox, Slack, and Outlook running. At this point, I doubt that crafting my data types for cache friendliness is going to offer a significant payoff. Creating data types that are easy to work with is likely more important.&lt;/p&gt;
&lt;p&gt;I do think, however, that it's important to understand these concepts. If I do need to tune the performance in the future, then I know where to look.&lt;/p&gt;</description><category>ray tracing</category><category>rust</category><guid>https://kylemdouglass.com/posts/data-type-alignment-for-ray-tracing-in-rust/</guid><pubDate>Mon, 24 Feb 2025 07:40:00 GMT</pubDate></item><item><title>A Simple Object-Space Telecentric System</title><link>https://kylemdouglass.com/posts/a-simple-object-space-telecentric-system/</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;h2&gt;Object-space telecentricity&lt;/h2&gt;
&lt;p&gt;I have been working on a software package recently for optical systems design. The process of building the package has proceeded like this:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Think of a particular case that I want to model; for example an infinite conjugate afocal system&lt;/li&gt;
&lt;li&gt;Implement it in the code&lt;/li&gt;
&lt;li&gt;Discover that the code doesn't work&lt;/li&gt;
&lt;li&gt;Create a test case that helps debug the code&lt;/li&gt;
&lt;li&gt;Repeat&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I am modeling a telecentric lens in the current iteration of this loop. To keep things simple, I am limiting myself to an &lt;a href="https://en.wikipedia.org/wiki/Telecentric_lens#Object-space_telecentric_lenses"&gt;object-space telecentric system&lt;/a&gt;. This was more challenging than I expected. In part, the reason is that I was trying to infer whether a system was or was not telecentric from the lens prescription data and a ray trace, which has two problems:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;I need to do a floating point comparison between two numbers to say whether a system is telecentric. Either the chief ray angle in object-space has to be zero or the entrance pupil must be located at infinity. Floating point comparisons are notoriously difficult to get right, and if you're doing them then you might want to rethink what you're trying to model.&lt;/li&gt;
&lt;li&gt;Numerous checks are needed before we can even trace any rays. For example, I should check first whether the user placed the object at infinity. This would form the image in the same plane as the aperture stop, which does not really make sense.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I find it interesting that &lt;a href="https://support.zemax.com/hc/en-us/articles/1500005488201-Modeling-a-lens-that-is-telecentric-in-image-space"&gt;Zemax addresses these problems&lt;/a&gt; by introducing object-space telecentricity as an extra boolean flag that forces the chief ray angle to be zero in the object-space. In other words, the user needs to know what they're doing and to specify that they want telecentricity from the beginning.&lt;/p&gt;
&lt;h2&gt;An object-space telecentric example&lt;/h2&gt;
&lt;p&gt;I adapted the following example from lens data presented in this video: &lt;a href="https://www.youtube.com/watch?v=JfstTsuNAz0"&gt;https://www.youtube.com/watch?v=JfstTsuNAz0&lt;/a&gt;. Notably, the object distance was increased by nearly a factor of two from what was given in the video so that the image plane was at a finite distance from the lens. Paraxial ray trace results were computed by hand.&lt;/p&gt;
&lt;table border="1"&gt;
    &lt;caption&gt;
        A simple object-space telecentric system comprising a planoconvex lens and a stop.
    &lt;/caption&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th scope="row"&gt;Surface&lt;/th&gt;
            &lt;th&gt;0&lt;/th&gt;
            &lt;th&gt;1&lt;/th&gt;
            &lt;th&gt;2&lt;/th&gt;
            &lt;th&gt;3&lt;/th&gt;
            &lt;th&gt;4&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;th scope="row"&gt;Comment&lt;/th&gt;
            &lt;td&gt;OBJ&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;STOP&lt;/td&gt;
            &lt;td&gt;IMG&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;th scope="row"&gt;\( R \)&lt;/th&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;\( \infty \)&lt;/td&gt;
            &lt;td&gt;-9.750&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th scope="row"&gt;\( t \)&lt;/th&gt;
            &lt;td&gt;29.4702&lt;/td&gt;
            &lt;td&gt;2&lt;/td&gt;
            &lt;td&gt;15.97699&lt;/td&gt;
            &lt;td&gt;17.323380&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th scope="row"&gt;\( n \)&lt;/th&gt;
            &lt;td&gt;1&lt;/td&gt;
            &lt;td&gt;1.610248&lt;/td&gt;
            &lt;td&gt;1&lt;/td&gt;
            &lt;td&gt;1&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;th scope="row"&gt;\( C \)&lt;/th&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;0&lt;/td&gt;
            &lt;td&gt;-0.10256&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
         &lt;/tr&gt; 
        &lt;tr&gt;
            &lt;th scope="row"&gt;\( -\Phi \)&lt;/th&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;0&lt;/td&gt;
            &lt;td&gt;-0.06259&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th scope="row"&gt;\( t/n \)&lt;/th&gt;
            &lt;td&gt;29.4702&lt;/td&gt;
            &lt;td&gt;1.24204&lt;/td&gt;
            &lt;td&gt;15.97699&lt;/td&gt;
            &lt;td&gt;17.323380&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;th scope="row"&gt;\( y \)&lt;/th&gt;
            &lt;td&gt;0&lt;/td&gt;
            &lt;td&gt;29.4702&lt;/td&gt;
            &lt;td&gt;30.712240&lt;/td&gt;
            &lt;td&gt;15.97699&lt;/td&gt;
            &lt;td&gt;0&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th scope="row"&gt;\( nu \)&lt;/th&gt;
            &lt;td&gt;1&lt;/td&gt;
            &lt;td&gt;1&lt;/td&gt;
            &lt;td&gt;-0.922279&lt;/td&gt;
            &lt;td&gt;-0.922279&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;th scope="row"&gt;\( \bar{y} \)&lt;/th&gt;
            &lt;td&gt;1&lt;/td&gt;
            &lt;td&gt;1&lt;/td&gt;
            &lt;td&gt;1&lt;/td&gt;
            &lt;td&gt;0&lt;/td&gt;
            &lt;td&gt;-1.084270&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th scope="row"&gt;\( n \bar{u} \)&lt;/th&gt;
            &lt;td&gt;0&lt;/td&gt;
            &lt;td&gt;0&lt;/td&gt;
            &lt;td&gt;-0.06259&lt;/td&gt;
            &lt;td&gt;-0.06259&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;This system is shown below with lens semi-diameters of 5 mm. Note that the stop is at the paraxial focus of the lens. The rays in the sketch cross the axis before the stop because of spherical aberration.&lt;/p&gt;
&lt;p&gt;&lt;svg viewbox="0, 0, 1344, 150" width="120%" fill="none" stroke="black" xmlns="http://www.w3.org/2000/svg"&gt;&lt;path d="M 632.646354675293 142.5 L 632.646354675293 142.5 L 632.646354675293 142.5 L 632.646354675293 135.39473819732666 L 632.646354675293 128.2894731760025 L 632.646354675293 121.18420815467834 L 632.646354675293 114.078946352005 L 632.646354675293 106.97368454933167 L 632.646354675293 99.86841952800751 L 632.646354675293 92.76315450668335 L 632.646354675293 85.65789270401001 L 632.646354675293 78.55263090133667 L 632.646354675293 71.44736909866333 L 632.646354675293 64.34210085868835 L 632.646354675293 57.236839056015015 L 632.646354675293 50.131577253341675 L 632.646354675293 43.0263090133667 L 632.646354675293 35.92104721069336 L 632.646354675293 28.81578540802002 L 632.646354675293 21.71052360534668 L 632.646354675293 14.60526180267334 L 632.646354675293 7.5 L 632.646354675293 7.5 L 641.0208705067635 7.5 L 641.0208705067635 7.5 L 644.972696185112 14.60526180267334 L 648.3765449523926 21.71052360534668 L 651.27783036232 28.81578540802002 L 653.7113556861877 35.92104721069336 L 655.7038663029671 43.0263090133667 L 657.275763630867 50.131577253341675 L 658.4422525763512 57.236839056015015 L 659.2141510248184 64.34210085868835 L 659.5984016060829 71.44736909866333 L 659.5984016060829 78.55263090133667 L 659.2141510248184 85.65789270401001 L 658.4422541856766 92.76315450668335 L 657.275763630867 99.86841952800751 L 655.7038679122925 106.97368454933167 L 653.7113556861877 114.078946352005 L 651.2778335809708 121.18420815467834 L 648.3765481710434 128.2894731760025 L 644.972696185112 135.39473819732666 L 641.0208705067635 142.5 L 641.0208705067635 142.5 L 632.646354675293 142.5 Z" stroke="black" stroke-width="1" stroke-linejoin="bevel" fill="none"&gt;&lt;/path&gt;&lt;path d="M 632.646354675293 142.5 L 632.646354675293 142.5 L 632.646354675293 135.39473819732666 L 632.646354675293 128.2894731760025 L 632.646354675293 121.18420815467834 L 632.646354675293 114.078946352005 L 632.646354675293 106.97368454933167 L 632.646354675293 99.86841952800751 L 632.646354675293 92.76315450668335 L 632.646354675293 85.65789270401001 L 632.646354675293 78.55263090133667 L 632.646354675293 71.44736909866333 L 632.646354675293 64.34210085868835 L 632.646354675293 57.236839056015015 L 632.646354675293 50.131577253341675 L 632.646354675293 43.0263090133667 L 632.646354675293 35.92104721069336 L 632.646354675293 28.81578540802002 L 632.646354675293 21.71052360534668 L 632.646354675293 14.60526180267334 L 632.646354675293 7.5" stroke="black" stroke-width="1" stroke-linejoin="miter" fill="none"&gt;&lt;/path&gt;&lt;path d="M 875.3357162475586 142.5 L 875.3357162475586 142.5 L 875.3357162475586 81.75" stroke="black" stroke-width="1" stroke-linejoin="miter" fill="none"&gt;&lt;/path&gt;&lt;path d="M 875.3357162475586 68.25 L 875.3357162475586 68.25 L 875.3357162475586 7.5" stroke="black" stroke-width="1" stroke-linejoin="miter" fill="none"&gt;&lt;/path&gt;&lt;path d="M 641.0208705067635 142.5 L 641.0208705067635 142.5 L 644.972696185112 135.39473819732666 L 648.3765481710434 128.2894731760025 L 651.2778335809708 121.18420815467834 L 653.7113556861877 114.078946352005 L 655.7038679122925 106.97368454933167 L 657.275763630867 99.86841952800751 L 658.4422541856766 92.76315450668335 L 659.2141510248184 85.65789270401001 L 659.5984016060829 78.55263090133667 L 659.5984016060829 71.44736909866333 L 659.2141510248184 64.34210085868835 L 658.4422525763512 57.236839056015015 L 657.275763630867 50.131577253341675 L 655.7038663029671 43.0263090133667 L 653.7113556861877 35.92104721069336 L 651.27783036232 28.81578540802002 L 648.3765449523926 21.71052360534668 L 644.972696185112 14.60526180267334 L 641.0208705067635 7.5" stroke="black" stroke-width="1" stroke-linejoin="miter" fill="none"&gt;&lt;/path&gt;&lt;path d="M 1109.2013397216797 142.5 L 1109.2013397216797 142.5 L 1109.2013397216797 135.39473819732666 L 1109.2013397216797 128.2894731760025 L 1109.2013397216797 121.18420815467834 L 1109.2013397216797 114.078946352005 L 1109.2013397216797 106.97368454933167 L 1109.2013397216797 99.86841952800751 L 1109.2013397216797 92.76315450668335 L 1109.2013397216797 85.65789270401001 L 1109.2013397216797 78.55263090133667 L 1109.2013397216797 71.44736909866333 L 1109.2013397216797 64.34210085868835 L 1109.2013397216797 57.236839056015015 L 1109.2013397216797 50.131577253341675 L 1109.2013397216797 43.0263090133667 L 1109.2013397216797 35.92104721069336 L 1109.2013397216797 28.81578540802002 L 1109.2013397216797 21.71052360534668 L 1109.2013397216797 14.60526180267334 L 1109.2013397216797 7.5" stroke="#999999" stroke-width="1" stroke-linejoin="miter" fill="none"&gt;&lt;/path&gt;&lt;path d="M 234.7986602783203 142.5 L 234.7986602783203 142.5 L 234.7986602783203 135.39473819732666 L 234.7986602783203 128.2894731760025 L 234.7986602783203 121.18420815467834 L 234.7986602783203 114.078946352005 L 234.7986602783203 106.97368454933167 L 234.7986602783203 99.86841952800751 L 234.7986602783203 92.76315450668335 L 234.7986602783203 85.65789270401001 L 234.7986602783203 78.55263090133667 L 234.7986602783203 71.44736909866333 L 234.7986602783203 64.34210085868835 L 234.7986602783203 57.236839056015015 L 234.7986602783203 50.131577253341675 L 234.7986602783203 43.0263090133667 L 234.7986602783203 35.92104721069336 L 234.7986602783203 28.81578540802002 L 234.7986602783203 21.71052360534668 L 234.7986602783203 14.60526180267334 L 234.7986602783203 7.5" stroke="#999999" stroke-width="1" stroke-linejoin="miter" fill="none"&gt;&lt;/path&gt;&lt;path d="M 234.7986602783203 115.5 L 234.7986602783203 115.5 L 632.646354675293 115.5 L 653.2606882452965 115.5 L 875.3357162475586 69.18727111816406 L 1109.2013397216797 20.41567325592041" stroke="red" stroke-width="0.5" stroke-linejoin="miter" fill="none"&gt;&lt;/path&gt;&lt;path d="M 234.7986602783203 75 L 234.7986602783203 75 L 632.646354675293 75 L 659.646354675293 75 L 875.3357162475586 75 L 1109.2013397216797 75" stroke="red" stroke-width="0.5" stroke-linejoin="miter" fill="none"&gt;&lt;/path&gt;&lt;path d="M 234.7986602783203 34.5 L 234.7986602783203 34.5 L 632.646354675293 34.5 L 653.2606882452965 34.5 L 875.3357162475586 80.81272888183594 L 1109.2013397216797 129.5843267440796" stroke="red" stroke-width="0.5" stroke-linejoin="miter" fill="none"&gt;&lt;/path&gt;&lt;path d="M 234.7986602783203 2451228.234375 L 234.7986602783203 2451228.234375 L 632.646354675293 2451193.4296875" stroke="red" stroke-width="0.5" stroke-linejoin="miter" fill="none"&gt;&lt;/path&gt;&lt;path d="M 234.7986602783203 2451187.734375 L 234.7986602783203 2451187.734375 L 632.646354675293 2451152.9296875" stroke="red" stroke-width="0.5" stroke-linejoin="miter" fill="none"&gt;&lt;/path&gt;&lt;path d="M 234.7986602783203 2451147.234375 L 234.7986602783203 2451147.234375 L 632.646354675293 2451112.4296875" stroke="red" stroke-width="0.5" stroke-linejoin="miter" fill="none"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/p&gt;
&lt;h2&gt;Remarks&lt;/h2&gt;
&lt;h3&gt;Marginal ray trace&lt;/h3&gt;
&lt;p&gt;At first the marginal ray trace was a bit confusing because the entrance pupil is at infinity. How can the marginal ray, which intersects the pupil at its edge, be traced when the pupil is at infinity? Then I remembered that I don't aim for the edge of the pupil when tracing the marginal ray. Instead, I launch a ray from the axis in the object plane at a random angle taking the surface with the smallest ray height as the aperture stop. (I chose a paraxial angle of 1 in the table above. Technically, this is called a pseudo-marginal ray. The real marginal ray is calculated from it by rescaling the surface intersection heights by the aperture stop semi-diameter.) Once you have the marginal ray in image space, just find its intersection with the axis to determine the image location.&lt;/p&gt;
&lt;h3&gt;Telecentric lens design&lt;/h3&gt;
&lt;p&gt;So how would an object-space telecentric design be implemented in software? First, I'd set an option that would force the chief ray angle to 0 in the object space. Then, I'd simply place a solve on the aperture stop that puts it at the location where the chief ray intersects the axis.&lt;/p&gt;</description><category>ray tracing</category><category>telecentricity</category><guid>https://kylemdouglass.com/posts/a-simple-object-space-telecentric-system/</guid><pubDate>Mon, 11 Mar 2024 07:59:17 GMT</pubDate></item></channel></rss>