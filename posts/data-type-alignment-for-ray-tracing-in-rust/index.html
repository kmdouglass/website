<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#
" lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="I explore data type size, alignment, and padding for ray tracing in Rust.">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Data Type Alignment for Ray Tracing in Rust | Kyle M. Douglass</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="../../rss.xml">
<link rel="canonical" href="https://kylemdouglass.com/posts/data-type-alignment-for-ray-tracing-in-rust/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Kyle M. Douglass">
<link rel="prev" href="../an-analog-led-dimmer-circuit/" title="An Analog LED Dimmer Circuit" type="text/html">
<meta property="og:site_name" content="Kyle M. Douglass">
<meta property="og:title" content="Data Type Alignment for Ray Tracing in Rust">
<meta property="og:url" content="https://kylemdouglass.com/posts/data-type-alignment-for-ray-tracing-in-rust/">
<meta property="og:description" content="I explore data type size, alignment, and padding for ray tracing in Rust.">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2025-02-24T08:40:00+01:00">
<meta property="article:tag" content="ray tracing">
<meta property="article:tag" content="rust">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-expand-md static-top mb-4
navbar-dark
bg-dark
"><div class="container">
<!-- This keeps the margins nice -->
        <a class="navbar-brand" href="../../">

            <span id="blog-title">Kyle M. Douglass</span>
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="bs-navbar">
            <ul class="navbar-nav mr-auto">
<li class="nav-item">
<a href="../../archive.html" class="nav-link">Archive</a>
                </li>
<li class="nav-item">
<a href="../../categories/" class="nav-link">Tags</a>
                </li>
<li class="nav-item">
<a href="../../rss.xml" class="nav-link">RSS feed</a>
                </li>
<li class="nav-item">
<a href="https://kmdouglass.github.io/" class="nav-link">Previous</a>

                
            </li>
</ul>
<ul class="navbar-nav navbar-right">
<li class="nav-item">
    <a href="index.md" id="sourcelink" class="nav-link">Source</a>
    </li>


                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
        
        
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Data Type Alignment for Ray Tracing in Rust</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    Kyle M. Douglass
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2025-02-24T08:40:00+01:00" itemprop="datePublished" title="2025-02-24 08:40">2025-02-24 08:40</time></a>
            </p>
                <p class="commentline">
    
    <a href="#disqus_thread" data-disqus-identifier="cache/posts/data-type-alignment-for-ray-tracing-in-rust.html">Comments</a>


            
        </p>
<p class="sourceline"><a href="index.md" class="sourcelink">Source</a></p>

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>I would like to clean up my 3D ray trace routines for my <a href="https://www.github.com/kmdouglass/cherry">Rust-based optical design library</a>. The proof of concept (PoC) is finished and I now I need to make the code easier to modify to better support the features that I want to add on the frontend. I suspect that I might be able to make some performance gains as well during refactoring. Towards this end, I want to take a look at my ray data type from the perspective of making it CPU cache friendly.</p>
<p>One of the current obstacles to adding more features to the GUI (for example color selection for different ray bundles) is how I handle individual rays. For the PoC it was fastest to add two additional fields to each ray to track where they come from and whether they are terminated:</p>
<div class="code"><pre class="code literal-block"><span class="k">struct</span> <span class="nc">Vec3</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">e</span>: <span class="p">[</span><span class="kt">f64</span><span class="p">;</span><span class="w"> </span><span class="mi">3</span><span class="p">],</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">Ray</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">pos</span>: <span class="nc">Vec3</span><span class="p">,</span>
<span class="w">    </span><span class="n">dir</span>: <span class="nc">Vec3</span><span class="p">,</span>
<span class="w">    </span><span class="n">terminated</span>: <span class="kt">bool</span><span class="p">,</span>
<span class="w">    </span><span class="n">field_id</span>: <span class="kt">usize</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>

<p>A ray is just two, 3-element arrays of floats that specify the coordinates of a point on the ray and its direction cosines. I have additionally included a boolean flag to indicate whether the ray has terminated, i.e. gone out-of-bounds of the system or failed to converge during calculation of the intersection point with a surface.</p>
<p>A ray fan is a collection of rays and is specified by a 3-tuple of wavelength, axis, and field; <code>field_id</code> really should not belong to an individual Ray because it can be stored along with the set of all rays for the current ray fan. I probably added it because it was the easiest thing to do at the time to get the application working.</p>
<h2>A deeper look into the Ray struct</h2>
<h3>Size of a ray</h3>
<p>Let's first look to see how much space the Ray struct occupies.</p>
<div class="code"><pre class="code literal-block"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span><span class="p">;</span>

<span class="cp">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="nc">Vec3</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">e</span>: <span class="p">[</span><span class="kt">f64</span><span class="p">;</span><span class="w"> </span><span class="mi">3</span><span class="p">],</span>
<span class="p">}</span>

<span class="cp">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="nc">Ray</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">pos</span>: <span class="nc">Vec3</span><span class="p">,</span>
<span class="w">    </span><span class="n">dir</span>: <span class="nc">Vec3</span><span class="p">,</span>
<span class="w">    </span><span class="n">terminated</span>: <span class="kt">bool</span><span class="p">,</span>
<span class="w">    </span><span class="n">field_id</span>: <span class="kt">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Size of ray: {:?}"</span><span class="p">,</span><span class="w"> </span><span class="n">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;</span><span class="n">Ray</span><span class="o">&gt;</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>

<p>The <code>Ray</code> struct occupies 64 bytes in memory. Does this make sense?</p>
<p>The sizes of the individual fields are:</p>
<table>
<thead><tr>
<th>Field</th>
<th>Size, bytes</th>
</tr></thead>
<tbody>
<tr>
<td>pos</td>
<td>24</td>
</tr>
<tr>
<td>dir</td>
<td>24</td>
</tr>
<tr>
<td>terminated</td>
<td>1</td>
</tr>
<tr>
<td>field_id</td>
<td>8*</td>
</tr>
</tbody>
</table>
<p><code>pos</code> and <code>dir</code> are each 24 bytes because they are each composed of three 64-bit floats and 8 bits = 1 byte. <code>terminated</code> is only one byte because it is a boolean. <code>field_id</code> is a <a href="https://doc.rust-lang.org/std/primitive.usize.html">usize</a>, which means that it depends on the compilation target. On 64-bit targets, such as x86_64, it is 64 bits = 8 bytes in size.</p>
<p>Adding the sizes in the above table gives 57 bytes, not 64 bytes as was output from the example code. Why is this?</p>
<h3>Alignment and padding</h3>
<p><a href="https://en.wikipedia.org/wiki/Data_structure_alignment">Alignment</a> refers to the layout of a data type in memory and how it is accessed. CPUs read memory in chunks that are equal in size to the <a href="https://en.wikipedia.org/wiki/Word_(computer_architecture)">word size</a>. Misaligned data is inefficient to access because the CPU requires more cycles than is necessary to fetch the data.</p>
<p>Natural alignment refers to the most efficient alignment of a data type for CPU access. To achieve natural alignment, a compiler can introduce padding between fields of a struct so that the memory address of a field or datatype is a multiple of the field's/data type's alignment.</p>
<p>As an example of misalignment, consider a 4-byte integer and that starts at memory address 5. The CPU has 32-bit memory words. To read the data, the CPU must:</p>
<ol>
<li>read bytes 4-7,</li>
<li>read bytes 8-11,</li>
<li>and combine the relevant parts of both reads to get the 4 bytes, i.e. bytes 5 - 8.</li>
</ol>
<p>Notice that we must specify the memory word size to determine whether a data type is misaligned.</p>
<p>Here is an important question: <strong>why can't the CPU just start reading from memory address 5?</strong> The answer, as far as I can tell, is that it just can't. This is not how the CPU, RAM, and memory bus are wired.</p>
<h3>Alignment in Rust</h3>
<p><a href="https://doc.rust-lang.org/reference/type-layout.html#size-and-alignment">Alignment in Rust</a> is defined as follows:</p>
<blockquote>
<p>The alignment of a value specifies what addresses are valid to store the value at. A value of alignment n must only be stored at an address that is a multiple of n.</p>
</blockquote>
<p><a href="https://doc.rust-lang.org/reference/type-layout.html#the-rust-representation">The Rust compiler only guarantees the following</a> when it comes to padding fields in structs:</p>
<blockquote>
<ol>
<li>The fields are properly aligned.</li>
<li>The fields do not overlap.</li>
<li>The alignment of the type is at least the maximum alignment of its fields.</li>
</ol>
</blockquote>
<p>So for my <code>Ray</code> data type, its alignment is 8 because the maximum alignment of its fields is 8 bytes. (<code>pos</code> and <code>dir</code> are composed of 8-byte floating point numbers). The addresses of its fields are:</p>
<div class="code"><pre class="code literal-block"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Ray</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">pos</span>: <span class="nc">Vec3</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">e</span>: <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">]</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="n">dir</span>: <span class="nc">Vec3</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">e</span>: <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">]</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="n">terminated</span>: <span class="nc">false</span><span class="p">,</span>
<span class="w">        </span><span class="n">field_id</span>: <span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Address of ray.pos: {:p}"</span><span class="p">,</span><span class="w"> </span><span class="n">ptr</span>::<span class="n">addr_of</span><span class="o">!</span><span class="p">(</span><span class="n">ray</span><span class="p">.</span><span class="n">pos</span><span class="p">));</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Address of ray.dir: {:p}"</span><span class="p">,</span><span class="w"> </span><span class="n">ptr</span>::<span class="n">addr_of</span><span class="o">!</span><span class="p">(</span><span class="n">ray</span><span class="p">.</span><span class="n">dir</span><span class="p">));</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Address of ray.terminated: {:p}"</span><span class="p">,</span><span class="w"> </span><span class="n">ptr</span>::<span class="n">addr_of</span><span class="o">!</span><span class="p">(</span><span class="n">ray</span><span class="p">.</span><span class="n">terminated</span><span class="p">));</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Address of ray.field_id: {:p}"</span><span class="p">,</span><span class="w"> </span><span class="n">ptr</span>::<span class="n">addr_of</span><span class="o">!</span><span class="p">(</span><span class="n">ray</span><span class="p">.</span><span class="n">field_id</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>I got the following results, which will vary from system-to-system and probably run-to-run:</p>
<div class="code"><pre class="code literal-block"><span class="go">Address of ray.pos: 0x7fff076c6b50</span>
<span class="go">Address of ray.dir: 0x7fff076c6b68</span>
<span class="go">Address of ray.terminated: 0x7fff076c6b88</span>
<span class="go">Address of ray.field_id: 0x7fff076c6b80</span>
</pre></div>

<p>So the <code>pos</code> field comes first at address <code>0x6b50</code> (omitting the most significant hexadecimal digits). Then, 24 bytes later, comes <code>dir</code> at address <code>0x6b68</code>. Note that the difference is hexadecimal 0x18, which is decimal 16 + 8 = 24! So <code>pos</code> really occupies 24 bytes like we previously calculated.</p>
<p>Next comes <code>field_id</code> and not <code>terminated</code>. It is <code>0x6b80 - 0x6b68 = 0x0018</code>, or 24 bytes after <code>dir</code> like before. So far we have no padding, but the compiler did swap the order of the fields. Finally, <code>terminated</code> is 8 bytes after <code>field_id</code> because <code>field_id</code> is 8-byte aligned. This means that the Rust compiler must have placed 7 bytes of padding after the <code>terminated</code> field.</p>
<h2>What makes a good data type?</h2>
<p>As I mentioned, I already know that <code>field_id</code> shouldn't belong to the ray for reasons related to data access by the programmer. So the reason for removing it from the <code>Ray</code> struct is not related to performance. But what about the <code>terminated</code> bool? Well, in this case, it's resulting in 7 extra bytes of padding for each ray!</p>
<div class="code"><pre class="code literal-block"><span class="cp">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="nc">Vec3</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">e</span>: <span class="p">[</span><span class="kt">f64</span><span class="p">;</span><span class="w"> </span><span class="mi">3</span><span class="p">],</span>
<span class="p">}</span>

<span class="cp">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="nc">Ray</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">pos</span>: <span class="nc">Vec3</span><span class="p">,</span>
<span class="w">    </span><span class="n">dir</span>: <span class="nc">Vec3</span><span class="p">,</span>
<span class="w">    </span><span class="n">terminated</span>: <span class="kt">bool</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Ray</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">pos</span>: <span class="nc">Vec3</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">e</span>: <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">]</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="n">dir</span>: <span class="nc">Vec3</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">e</span>: <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">]</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="n">terminated</span>: <span class="nc">false</span><span class="p">,</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"Size of ray: {:?}"</span><span class="p">,</span><span class="w"> </span><span class="n">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;</span><span class="n">Ray</span><span class="o">&gt;</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>

<p>This program prints <code>Size of ray : 56</code>, but 24 + 24 + 1 = 49. In both versions we waste 7 bytes.</p>
<h3>Fitting a Ray into the CPU cache</h3>
<p>Do I have a good reason to remove <code>terminated</code> from the <code>Ray</code> struct because it wastes space? Consider the following:</p>
<p>We want as many <code>Ray</code> instances as possible to fit within a CPU cache line if we want to maximize performance. (Note that I'm not saying that we necessarily want to maximize performance because that comes with tradeoffs.) Each CPU core on my AMD Ryzen 7 has a 64 kB L1 cache with 64 byte cache lines. This means that I can fit only 1 of the current version of <code>Ray</code> into each cache line for a total of 64 kB / 64 bytes = 1024 rays maximum in the L1 cache of each core. If I remove <code>field_size</code> and <code>terminated</code>, then the size of a ray becomes 48 bytes. Unfortunately, this means that only one <code>Ray</code> instance fits in a cache line, just as before with a 64 byte <code>Ray</code>.</p>
<p>But, if I also reduce my precision to 32-bit floats, then the size of a <code>Ray</code> becomes 6 * 4 = 24 bytes and I have doubled the number of rays that fit in L1 cache.</p>
<p>Now what if I reduced the precision but kept <code>terminated</code>? Then I get 6 * 4 + 8 = 32 bytes per Ray and I still have 2 rays per cache line.</p>
<p>I conclude that there is no reason to remove <code>terminated</code> for performance reasons. Reducing my floating point precision would produce a more noticeable effect on the cache locality of the <code>Ray</code> data type.</p>
<h2>Does all of this matter?</h2>
<p>My Ryzen 7 laptop can trace about 600 rays through 3 surfaces in 3.8 microseconds with Firefox, Slack, and Outlook running. At this point, I doubt that crafting my data types for cache friendliness is going to offer a significant payoff. Creating data types that are easy to work with is likely more important.</p>
<p>I do think, however, that it's important to understand these concepts. If I do need to tune the performance in the future, then I know where to look.</p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/ray-tracing/" rel="tag">ray tracing</a></li>
            <li><a class="tag p-category" href="../../categories/rust/" rel="tag">rust</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../an-analog-led-dimmer-circuit/" rel="prev" title="An Analog LED Dimmer Circuit">Previous post</a>
            </li>
        </ul></nav></aside><section class="comments hidden-print"><h2>Comments</h2>
        
    
        <div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="kyle-m-douglass",
            disqus_url="https://kylemdouglass.com/posts/data-type-alignment-for-ray-tracing-in-rust/",
        disqus_title="Data Type Alignment for Ray Tracing in Rust",
        disqus_identifier="cache/posts/data-type-alignment-for-ray-tracing-in-rust.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
    <a href="https://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>


        </section></article><script>var disqus_shortname="kyle-m-douglass";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script><!--End of body content--><footer id="footer">
            Contents © 2025         <a href="mailto:kyle.m.douglass@gmail.com">Kyle M. Douglass</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
<a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
<img alt="Creative Commons License BY-NC-SA" style="border-width:0; margin-bottom:12px;" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"></a>
            
            
        </footer>
</div>
</div>


        <script src="../../assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
    </script>
</body>
</html>
